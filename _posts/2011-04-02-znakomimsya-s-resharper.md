---
id: 532
title: 'Знакомимся с ReSharper'
date: '2011-04-02T19:48:16+00:00'
author: serge
layout: post
guid: 'http://sotnyk.com/?p=532'
permalink: /2011/04/02/znakomimsya-s-resharper/
---

![](https://sotnyk.github.io/wp-content/uploads/2011/04/Logo.jpg "ReSharper Logo")

Готовлюсь к очередной конференции в Желтых Водах, восстанавливаю один из своих старых проектов. Параллельно решил посмотреть на ReSharper. Читал про этот плагин к Visual Studio достаточно давно, но, попробовать на практике руки не доходили. На нашей фирме мы используем лицензионное ПО, а ReSharper является платным продуктом. Так что ставить оценочный продукт (демо-версию) я стараюсь только тогда, когда действительно планирую с ним что-то сделать.

Итак, [ReSharper](http://www.jetbrains.com/resharper/index.html) – что это такое. Это дополнение к VS, которое позволяет произвести следующие действия:

- Статический анализ кода с подсветкой ошибок и неоптимальных по тем или иным причинам фрагментов.
- Возможность быстрого исправления ошибок и замечаний, удаление избыточных элементов кода (Quick-Fixes).
- Context Actions — быстрые преобразования кода по типичным сценариям (например, инвертирование булевского выражения в условном операторе с одновременной перестановкой веток). Набор доступных Context Actions формируется в зависимости от контекста.
- Быстрая навигация по коду: поиск мест использования объекта программы, операции быстрого перехода к связанным объектам и т.д.
- Подсказки при вводе кода — улучшенный вариант IntelliSense, учитывающий контекст (например, ожидаемый тип выражения).
- Автоматизированный рефакторинг.
- Поддержка юнит-тестирования с использованием NUnit и MSTest.
- Value Analysis — анализ control flow и data flow внутри функций, выявляющий избыточные проверки, присваивания и логические операторы, ветки кода, недостижимые ни при каких входных данных, показывающий предупреждения о возможных исключениях при вызове методов и операторов.
- Помощь при интернационализации .NET-приложений.

В общем, по большей части – улучшение кода. Полностью все проверять и описывать в этом посте не собираюсь, но некоторые моменты рассмотрим. Прежде всего – что такое «улучшение кода»? С моей точки зрения, работа программиста – это борьба со сложностью программы. Для этого придуманы различные методики вроде структурного программирования, объектно-ориентированного программирования, компонентного программирования, вводятся (хотя иногда происходит и откат обратно) все более строгие проверки типов в новых языках. Все это позволяет сделать код более понятным, прогнозируемым и способным к изменениям по сравнению с тем, что было раньше. Именно, исходя из данных критериев, и оценим работу ReSharper.

Для «решарпинга» старого проекта, удобно запустить в контекстном меню солюшена или проекта пункт «Find code issues». Это запустит процесс анализа кода и вывод диалогового окна с общим списком обнаруженных проблем (с точки зрения текущих настроек).

Приступим. Прежде всего, есть много предложений следующего вида:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image003.png "image003")](https://sotnyk.github.io/wp-content/uploads/2011/04/image003.png)

Код становится короче, в читабельности выигрываем. Однозначно одобряю.  
Сделать поле read-only или преобразовать его в константу:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image005.png "image005")](https://sotnyk.github.io/wp-content/uploads/2011/04/image005.png)

Так надежнее. Одобряю.

Очень хорошая группа правил занимается проверкой того, соответствует ли стиль идентификатора тому, что за объект он представляет. В большинстве случаев я согласен. У меня такие несоответствия встречаются из-за того, что есть достаточно долгий опыт работы с достаточно разными соглашениями (C++, Delphi, Java, теперь C#). И время от времени мозги забывают «переключить раскладку клавиатуры».

В общем, такие правила делают чтение кода более удобным. Иначе это напоминает разговор с человеком, имеющим акцент – понять можно, но нужно тратить дополнительные усилия. Но здесь тоже нужно применять с умом. Обратил внимание на следующие случаи, когда не нужно «улучшать» код в соответствии с рекомендациями:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image007.png "image007")](https://sotnyk.github.io/wp-content/uploads/2011/04/image007.png)

В данном случае, идет моделирование физического процесса. И в формулах, описывающих этот процесс, используется апостроф «’», как признак производной по времени. Чтобы легко было проверять соответствие кода и формул, я часто использую простые правила транслитерации. В данном проекте, например, апостроф заменялся символом подчеркивания. Это не соответствует code agreement, но делает отладку программ с формулами более удобной. Это преимущество в данном конкретном случае для меня перевешивает недостатки, поэтому здесь я менять не собираюсь. То же относится и к случаю, когда в формулах встречаются большие и малые буквы – лучше повторить их написание из формулы, чем через месяц мучительно вспоминать, кто есть ху…  
  
Еще момент – обработчики событий.

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image009.png "image009")](https://sotnyk.github.io/wp-content/uploads/2011/04/image009.png)

Да, они являются методами, поэтому вроде бы как должны начинаться с большой буквы, но… Имена обработчиков по умолчанию соответствуют имени контрола, который, в свою очередь, является, как правило, приватным полем и по правилам должен писаться с маленькой буквы. Кроме того, дизайнером форм используется добавление подчеркивания и названия события, что также не одобрено Code Agreement. Но этот случай (обработчики событий) фактически представляют собой отдельный сценарий, который, как мне кажется, разработчики РеШарпера вполне могли бы выделить в отдельный класс. В общем, тут я тоже не согласен с их рекомендацией.

Рекомендации по деланью методов статическими, упрятыванию переменных внутрь программных блоков, как правило, нахожу вполне разумными. Туда же уходят рекомендации по работе с базовыми типами:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image011.png "image011")](https://sotnyk.github.io/wp-content/uploads/2011/04/image011.png)

Согласен. Если не нужно ничего специфического, лучше использовать базовый тип.  
А вот целый ворох предложений

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image013.png "image013")](https://sotnyk.github.io/wp-content/uploads/2011/04/image013.png)

Прежде всего, нам предлагают изменить конструкцию if на case:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image0151.png "image015")](https://sotnyk.github.io/wp-content/uploads/2011/04/image0151.png)

Не знаю, я мысленно воспринимаю else if как цельную конструкцию. Switch/case, на которую она заменилась, мне кажется менее удобочитаемой. Хотя бы потому, что она еще дальше ушла вправо. Кстати, тут C-подобный синтаксис сослужил (с моей личной точки зрения) плохую службу C# (да и Java тоже). Имеющуюся в некоторых языках программирования конструкцию:

if (условие)  
…  
\[elseif (условие)  
…  
\]  
\[else  
…\]  
endif

я считаю гораздо более читабельной. Возможно, правда этот код компилятором будет оптимизирован лучше, но не думаю, что тут будет большой выигрыш. Читабельность важнее. Так что, я против такой корректировки кода.

Идем дальше. Огромнейшее количество предложений по «улучшению» кода путем отказа от явной декларации типа:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image017.png "image017")](https://sotnyk.github.io/wp-content/uploads/2011/04/image017.png)  
[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image019.png "image019")](https://sotnyk.github.io/wp-content/uploads/2011/04/image019.png)

Тут я совершенно не согласен. Конечно, отказа от строгой типизации тут нет, но то, что тип переменной может неожиданно измениться после того, как я её проинициализирую другим аргументом (при корректировке кода), уже настораживает. Кроме того, мне очень неудобно читать код, когда мне нужно делать дополнительное усилие для того, чтобы понять, а где этот тип прописан, слева или справа? Тип всегда должен быть слева и все тут. Так что у себя я категорически отключаю данную возможность. Впрочем, как и вообще стараюсь не пользоваться var-переменными. С моей точки зрения, это было крайне вредным приобретением C# по сравнению с версией 2.0. Пошел уход в скриптоподобность в худшем смысле этого слова (на самом деле, при определенной самодисциплине и на скриптовых языках можно писать вполне прилично).

Да, кстати, в предыдущем примере опять переменная названа не по Фен-Шую – но это название поля в формате WAV. Это тоже случай, когда лучше не идти на поводу у решарпера.

Излишние преобразования типов:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image021.png "image021")](https://sotnyk.github.io/wp-content/uploads/2011/04/image021.png)

Этот фрагмент предлагается заменить на следующий:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image023.png "image023")](https://sotnyk.github.io/wp-content/uploads/2011/04/image023.png)

Вроде выглядит красивее. Но ведь не от фонаря же я такое писал. Причина банальна – сложноуловимые ошибки с потерей точности, переходом границ размерности типа приучили в некоторых случаях писать код, в котором уверен, что какого типа, где обрабатывается. Если решарпер не будет делать ошибок в этом, то это неплохо.

Кстати, по поводу преобразования типов – некрасиво оно сделано в C#. Да, опять пошли на поводу у C++ и сделали его вида: (type) value. И это вынуждает в случае выражений строить громоздкие конструкции из скобок. Но ведь в том же С++ есть и гораздо более удобочитаемый вариант type(value). К такой конструкции я привык еще с Pascal/Delphi и мне её до сих пор не хватает в C#. А вместо этого вводят var…  
  
Предупреждение о том, что переменную надо бы локализовать:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image025.png "image025")](https://sotnyk.github.io/wp-content/uploads/2011/04/image025.png)

Полезная штука. В данном конкретном случае это не важно – пример скорее исследовательский, но я просто могу отключить эти предупреждения в нем и не реагировать. Зато когда нужно… Помню, как нудно вылавливать все подобные вещи из кода. Так что +1

Предупреждения о неиспользуемых присваиваниях (в основном при инициализации переменных). В большинстве случаев +1.

Убирание излишнего else:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image027.png "image027")](https://sotnyk.github.io/wp-content/uploads/2011/04/image027.png)

Преобразовываем вот в такое:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image029.png "image029")](https://sotnyk.github.io/wp-content/uploads/2011/04/image029.png)

Да, код стал короче. Но появилась одна проблема. У нас есть выходы на разном уровне вложенности. Один на самом внешнем, в конце метода, а другой в середине, внутри if. Многие теоретики считают, что результат в принципе должен возвращаться только в одном методе, иначе тяжело читается. Мне кажется (исходя из личного опыта), что в такую крайность впадать не следует и вполне читабельными являются также серии выходов, если они однотипны и на одном уровне вложенности (if или switch/case). Но полученный от решарпера код мне не нравится. -1 за эту рекомендацию.

Удаление ненужных квалификаторов:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image031.png "image031")](https://sotnyk.github.io/wp-content/uploads/2011/04/image031.png)

Согласен. Без них лучше.

Удаление ненужного ToString():

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image033.png "image033")](https://sotnyk.github.io/wp-content/uploads/2011/04/image033.png)

В принципе, я еще с Java привык, что компилятор особым образом опекает строки и позволяет в строковых выражениях что угодно преобразовать к строке путем неявного вызова ToString(). Но точно также у меня не вызывает особых проблем и явное указание. А многие люди считают данный момент отходом от строгой типизации. Так что отнесу данное улучшение к спорным.

Удаление квалификатора .this:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image035.png "image035")](https://sotnyk.github.io/wp-content/uploads/2011/04/image035.png)

Ну не знаю. Тут тоже на вкус и цвет… Я бы удалял, но сказать, что такой код сильно повысит читабельность, не стал бы.

Инвертирование if, чтобы убрать уровень вложенности. Было:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image037.png "image037")](https://sotnyk.github.io/wp-content/uploads/2011/04/image037.png)

Стало:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image039.png "image039")](https://sotnyk.github.io/wp-content/uploads/2011/04/image039.png)

В принципе, мне нравится. Большая вложенность – это в принципе зло, которое затрудняет работу с кодом. Короткие «плоские» методы всегда проще читать, чем один большой суперметод с десятком уровней вложенности. +1  
  
Преобразование for в foreach. Исходный вариант:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image041.png "image041")](https://sotnyk.github.io/wp-content/uploads/2011/04/image041.png)

Делаем два последовательных преобразования цикла и оказывается, что полученный код не компилируется:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image043.png "image043")](https://sotnyk.github.io/wp-content/uploads/2011/04/image043.png)

В обоих циклах решарпер использовал одно и то же имя для переменной. Ладно, откатим и поправим ручками, чтобы оценить задумку:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image045.png "image045")](https://sotnyk.github.io/wp-content/uploads/2011/04/image045.png)

Ну что же, так действительно удобнее читать код. В чисто вычислительных циклах я немножко настороженно отношусь к foreach, поскольку он слегка менее производителен при работе с простыми типами. Но тут вся работа происходит внутри вызываемого метода (блин, опять назвал не по Фен Шую) distanceSegment(), так что соглашусь, что тут +1. Код стал красивее и проще.

Преобразование в автосвойство:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image047.png "image047")](https://sotnyk.github.io/wp-content/uploads/2011/04/image047.png)

Этот код писался, когда в языке C# еще не было автосвойств. Получаем:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image049.png "image049")](https://sotnyk.github.io/wp-content/uploads/2011/04/image049.png)

Ну что ж, мне так нравится больше. Если нужно будет совершать дополнительные действия при присваивании, свойства всегда можно сделать обычными. Хотя, еще вариант – данные поля вполне можно было бы сделать просто readonly и вообще обойтись без свойств. Конечно, если не нужно сериализовать в XML. Там нужны именно свойства. Так что разработчики решарпера правы, что использовали в общем случае свойства.

А теперь дойдем до LINQ. Вот здесь, решарпер предлагает заменить цикл LINQ-выражением:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image051.png "image051")](https://sotnyk.github.io/wp-content/uploads/2011/04/image051.png)

Заменяем:

[![](https://sotnyk.github.io/wp-content/uploads/2011/04/image053.png "image053")](https://sotnyk.github.io/wp-content/uploads/2011/04/image053.png)

Вроде стал короче. Лучше ли читается? Мне точно нет. Как по мне – это читабельность REGEX: очень коротко, емко, но чтобы разобрать смысл, нужно дождаться, пока мозги вскипят. Здесь пример небольшой, но чем больше LINQ, тем сложнее мне его читать. Обычно сложнее, чем соответствующий процедурный код. Возможно, у меня просто мозги работают по-другому. Но такую замену я не рекомендую. От себя лично. Но к счастью для таких как я есть и обратное преобразование 🙂

На первый раз, пожалуй, закончу. Остались нерассмотренными многие вопросы. Например, связанные с MVC-приложениями. Но думаю, что общее впечатление составить можно. Отключив некоторые сомнительные рекомендации и слегка (совсем слегка) включая мозги для остальных, получаем отличный плагин. Жаль, что не дешевый.