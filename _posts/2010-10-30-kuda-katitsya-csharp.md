---
id: 393
title: 'Куда катится C#?'
date: '2010-10-30T02:27:11+00:00'
author: serge
layout: post
guid: 'http://sotnyk.com/?p=393'
permalink: /2010/10/30/kuda-katitsya-csharp/
---

![](https://sotnyk.github.io/wp-content/uploads/2010/10/mouse.jpg)
Я люблю C#. В настоящий момент этот язык вместе со своим окружением (.Net Framework) дают мне возможность наслаждаться процессом написания программы и получаемым результатом. Но я слышу нехорошие звоночки, которые напрягают и заставляют задуматься о том, что возможно пора посмотреть еще куда-нибудь…

Я не планирую делать систематический обзор – просто опишу то, что вспомнится сейчас, в ночь с пятницы на субботу.  
  
**Сложность**

От версии к версии язык становится сложнее. Конечно, хочется удовлетворить как можно больше программистов. Из-за этого в язык включаются возможности, которые многим кажутся сомнительными и необязательными. Казалось бы, чем плоха сложность языка для программистов – ведь главное, чтобы компилятор переводил все в байт-код виртуальной машины? Так что эта сложность касается только разработчиков компилятора. А они находятся в Майкрософте и получают бешеные деньги. А остальные разработчики могут просто использовать подмножество языка, которое им ближе и все?

На самом деле, все немного совсем не так…

1\. Сферический программист в вакууме, вполне может использовать то подмножество языка, которое он знает, не задумываясь о других конструкциях. Реальный программист работает с кодами других разработчиков, поэтому ему приходится учить другие конструкции. Или же он не может полноценно работать с чужим кодом.

2\. Компилятор пишут не только в Майкрософте. Есть такое начинание, как C# для Linux/Mac – Mono (и родственный проект Moonlight). Думаю, что именно благодаря безудержному усложнению как C#, так и его окружения, Mono постоянно находится в отстающих. Подчас сильно отстающих. А в некоторых вещах (WPF) даже не делает попыток догнать. Да и ошибок, судя по отзывам людей, пытавшихся делать на Mono серьезные приложения, хватает. Но думаю, что и родному, майкрософтовскому компилятору, сложность языка не прибавляет надежности и качества.

> Небольшое отступление. В свое время, когда язык Ада только появился, его ругали за большую сложность. Из-за этого в течение нескольких лет после появления первых стандартов, не было хороших оптимизирующих компиляторов с этого языка. Сегодняшний C# в его 4-й версии, субъективно мне кажется существенно сложнее Ады.

3\. Более сложный язык нужно дольше учить. Мне не хочется терять на это времени сверх необходимого. Это сродни тому, что я не хочу учить иероглифический язык, поскольку считаю это нерациональным.

Конечно же, любой программист расстраивается, когда узнает, что его любимые в других языках штуки в новую редакцию языка не включили, а что-то, что считает необязательным – включили. Есть такой пример и у меня.

Необязательным считаю LINQ. Не вижу необходимости вводить в язык возможность писать в стиле другого языка. Возьмем, к примеру, [Java-библиотеку jOOQ](http://sourceforge.net/apps/trac/jooq/wiki/Examples). Вот как в ней предлагается писать SQL-запрос:

```java
 SelectQuery q = create.select()  
 .from(T_AUTHOR)  
 .join(T_BOOK).on(TAuthor.ID.equal(TBook.AUTHOR_ID))  
 .where(TAuthor.YEAR_OF_BIRTH.greaterThan(1920))  
 .orderBy(TBook.TITLE).getQuery();  
```

На мой взгляд, все достаточно компактно и понятно. (C# тоже поддерживает такой синтаксис для LINQ – просто этот пример был под руками). Понятнее ли, если в программе запрос написан почти в соответствии с синтаксисом SQL? (Почти – потому, что полного соответствия в LINQ все равно сложно достичь. Есть отличия.) На мой взгляд – понятность не увеличилась. А язык усложнился. И мне это пришлось изучать, тратить время.

А чего не хватает? Ну, например, виртуальных конструкторов. Это же тупо, когда наследуя класс с большим количеством конструкторов, их приходится опять объявлять! Более того, из-за отсутствия такого понятия, как виртуальный конструктор, мы не можем вызвать в коде, который не знает о типе-наследнике ничего, кроме того, что он унаследован от такого-то базового класса, конструктор с параметрами безопасным способом. Необходимо городить огороды либо с классом фабрикой (единственным смыслом существования которого есть создание другого класса), либо работать с рефлекшеном (а тут мы теряем преимущества строгой типизации). Первое громоздко (соответственно, больше подвержено ошибкам), второе небезопасно.

**WPF**

Эта тема настолько безбрежна, что постараюсь быть краток. Считаю WPF качественно реализованной, но неправильно спроектированной вещью.

Прежде всего, XAML. Он базируется на XML. В одном из [своих предыдущих постов](https://sotnyk.github.io/?p=173), я уже озвучивал своё мнение об XML. Вкратце – это попытка сделать строгий по синтаксису язык, который бы можно было редактировать и читать обычному человеку. В результате такого скрещивания, преимуществ не получили, зато есть одни недостатки – программа перед использованием XML все-таки нуждается в его синтаксическом разборе. При этом данные хранятся в очень «пухлом» виде. Немного спасает сжатие, но это дополнительный этап, который не упрощает и не ускоряет работу программ. Но бог с ними, с компьютерами – пусть работают. Но ведь и человеку с этим XML работать не очень-то хорошо. Читать реальные XML-файлы (а не куцые примеры из документации) – это сущий ад! Инициализационные файлы (тот же web.config) немного спасает то, что он дополнительно форматируется в виде, удобном для чтения – с комментариями, правильными отступами. Но вот XAML назвать удобным для чтения у меня язык не поворачивается.

В общем, я за подход, использованный в ProtocolBuffers. Бинарный формат, без особых наворотов, редактирование посредством инструментальных средств.

Это то, что касается XML. Но ведь это еще не все! XAML пошел дальше. Разработчикам показалось мало «красот» XML и в один язык добавили вставки на другом! Я имею в виду биндинги. Фактически, это вставки на совершенно другом, скриптообразном языке, которые практически не проверяются компилятором. Косвенно то, что это «б-р-р-р» и «ай-я-яй», подтверждает огромное количество проблем с биндингами у начинающих разработчиков.

Кстати, возможно я скажу что-то крамольное, но в большинстве случаев я не вижу ничего такого, если свойства визуальных компонентов будут заполняться в обработчике того или иного события, а не через биндинг. В этом случае компилятор будет «опекать» данные, не позволяя использовать не тот тип. Нет необходимости городить еще один огород – конвертеры. Их код как правило элементарен, но громоздок.

Думаю, что вся эта громоздкая, во многом интерпретируемая на лету система, виновата в тяжеловесности WPF-приложений. Они обычно долго запускаются, потребляют значительное количество памяти и приходится много полировать, чтобы они были «отзывчивыми» при работе.

> В свете этого интересен пример [ухода с WPF/Framework](http://blog.evernote.com/ru/2010/10/27/evernote-4-for-windows-is-here/) разработчиков популярного приложения Evernote. И действительно, новая версия, переписанная на C++, запускается практически мгновенно. Хотя, должен признать, что самой удобной у них все равно была версия 3.1, так что снесу 4-ю и поставлю ту, предпредыдущую… Похожие проблемы (борьба со шрифтами на платформе Mac) была и у разработчиков известного приложения Times Reader, который изначально был написан на Silverlight. Причем, проблемы эти были настолько серьезными, что издательству пришлось с нуля переписать своё приложение на Flex. Немного они не дождались версии 4.0, где вроде бы уже эти проблемы пофисшены. Хотя, я на Mac не работаю, поэтому не могу ни подтвердить, ни опровергнуть данный вопрос.

М-да, а обещал про WPF кратко…

**Scripting**

В последних версиях C#, наметился уход от парадигмы строгой типизации. [Процитирую себя же](http://www.iveonik.com/?p=126):

*… написание программы – это постоянная борьба со сложностью. Разрабатывая все новые методы борьбы с этой сложностью, мы пишем все более и более совершенные (ну ладно, согласен, иногда просто более сложные) программы.*

Важным элементом данной борьбы, который мне лично помогает, я считаю строгую типизацию. К сожалению, она под угрозой. Прежде всего, это поддержка динамических (читай – с неизвестным на этапе компиляции) типов. Конечно, их можно не использовать. Но боюсь, что неокрепшие умы вполне могут начать пользоваться данной возможностью направо и налево, не задумываясь о последствиях (менее надежные программы, более сложный для понимания код и т.п.).

Некоторым отходом от строгой типизации, я считаю даже введение «типа» var – когда тип переменной «вычисляется» компилятором на основе инициализирующего выражения. Несмотря на то, что такая переменная вполне строго типизирована, в программе возможно появление некоторых ошибок времени компиляции, которые требуют дополнительного внимания. Имеются в виду ошибки, которые компилятор показывает ниже объявления переменной потому, что там тип выражения не совпадает с тем, что был вычислен компилятором при инициализации. Также несколько затрудняется чтение чужих программ, поскольку мысленно приходится восстанавливать тип выражения. А это не всегда просто в случае сложных инициализаторов (те же LINQ-выражения).

**И все-таки он мне нравится**

C# пока мне нравится, не смотря ни на что. Наверное, это любовь? 😉 Если кто-то его также любит, как и я, то вот интересная ссылочка на книгу [“Программирование Windows Phone 7”](http://www.charlespetzold.com/phone/), которую в электронном виде бесплатно раздает автор, Чарльз Петцольд. Надеюсь, представлять не нужно? Качайте, пока бесплатно…