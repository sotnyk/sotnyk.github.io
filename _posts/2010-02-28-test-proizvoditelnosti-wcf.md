---
id: 82
title: 'Тест производительности WCF'
date: '2010-02-28T22:26:30+00:00'
author: serge
layout: post
guid: 'http://sotnyk.com/?p=82'
permalink: /2010/02/28/test-proizvoditelnosti-wcf/
---

Последнее время, у нас на фирме все большее количество проектов переводится на технологию WCF. Многие вещи, на которые раньше затрачивалась масса времени, теперь делаются элементарно. И вся сложность скрывается внутри .Net Framework. Но, как известно, бесплатный сыр… достается второй мышке… или как-то так. В общем, захотелось посмотреть, какова производительность при работе с WCF-приложениями, находящимися на одной машине (локально).  
  
Для этого был написан достаточно простой сервер (self-hosting), который принимает соединения по двум End-point-ам – Pipes и HTTP. У сервера был Также был добавлен клиент, вызывающий по данным End-point сервер, а для сравнения, выполняет еще и аналогичную операцию в пределах своего процесса. Операция имеет следующий вид:

\[csharp\]  
public class TestServer: ITestServer  
{  
 public string SimpleProcessingForString(string str)  
 {  
 return str.ToUpperInvariant();  
 }  
}  
\[/csharp\]

Для того, чтобы проверить вклад тех или иных факторов, выполнялся вызов данного метода по 30000 раз с предварительным созданием объекта (вызов одного и того же объекта) и с созданием нового объекта для каждого вызова (стиль работы как с WEB-службами).

**Полученные результаты:**  
Данные усреднены, пустой end-поинт соответствует локальному вызову метода. Запуск проводился на двухядерной машине с Vista. Если будете компилировать исходники у себя, обязательно запускайте их не из-под студии. Дебаггер студии очень сильно вмешивается в процесс.

- Processing test of PipeEndpoint done at 6067,971 msec. 30000 repeats
- Processing test of HTTP done at 17828,937 msec. 30000 repeats
- Processing test of \* done at 31,248 msec. 30000 repeats
- Creating test of PipeEndpoint done at 47418,84 msec. 30000 repeats
- Creating test of HTTP done at 21387,303 msec. 30000 repeats

\*Примечание – в вызове локального метода пустое имя канала.

**Выводы:**  
При работе через именованные пайпы, (предположительно – нужно еще проверить) используется бинарная сериализация. В совокупности с особенностями механизма, это приводит к более высокой (раза в 2.5 – 3) производительности по сравнению с HTTP на простых запросах. Однако следует отметить, огромнейшее отставание от внутрипроцессного вызова – около 200 раз! Отсюда сразу рекомендация – не прячьте в WCF-сервисах элементарные операции вроде той, что была приведена выше. Иначе производительность полученного решения может вас просто шокировать.  
При постоянном создании удаленного объекта, ситуация поменялась на противоположную – HTTP протокол здесь оказался гораздо менее тяжеловесным.

**Примечание:**  
Данный тест, как уже было сказано, проводился на Vista. На домашнем компьютере с XP, где стоят все обновления для ОС и фреймворка, производительность HTTP-транспорта была ниже. Скорее всего, это связано как с особенностями реализации протокола, так и с более производительной работой XML-парсера в Vista.

**Тестовый проект:**  
[ WCFSelfHostingTest.rar](code/WCFSelfHostingTest.rar) (исходные тексты и бинарники). Запускать вначале сервер, а затем клиент.