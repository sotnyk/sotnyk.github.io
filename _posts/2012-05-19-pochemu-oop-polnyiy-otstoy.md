---
id: 1168
title: 'Почему ООП - полный отстой (перевод)'
date: '2012-05-19T09:48:46+00:00'
author: serge
layout: post
guid: 'http://sotnyk.com/?p=1168'
permalink: /2012/05/19/pochemu-oop-polnyiy-otstoy/
---

!["Erlang"](https://sotnyk.github.io/wp-content/uploads/2012/05/Erlang-300x255.png)

_Есть достаточно известное (в узких кругах) эссе с весьма эпатажным названием – [Why OO Sucks](http://www.sics.se/~joe/bluetail/vol1/v1_oo.html). Его автор – архитектор языка Erlang, [Джо Армстронг](http://www.sics.se/~joe/). После непродолжительного поиска перевода (он мне был нужен по некоторым причинам), я его не нашел. Так что решил перевести сам – благо текст не очень длинный. Постарался сохранить авторскую формулировку там, где очень хотелось её поменять. Например, как и у автора, методы объектов названы функциями. Если где-то есть возражения по переводу – отписывайтесь в комментариях (или письмом). Поправлю. Свои мысли по поводу прочитанного выскажу позже._

**Why OO Sucks**

Когда я впервые ознакомился с идеей ООП, я был скептически настроен, хотя и не знал почему – просто ощущал, что это неправильно. После этого ознакомления, ООП стало очень популярным (далее я объясню, почему) и критика ООП стала чем-то вроде “богохульства в церкви”. Объектно-ориентированность стала чем-то, что должен иметь каждый респектабельный язык.

Когда Erlang стал популярным, нас часто спрашивали, “является Erlang ОО-языком?”. Конечно же, правильный ответ – “Нет, конечно, нет”. Но мы не говорили это вслух – пока мы не придумали серьезные нестандартные пути ответа на вопрос, что было бы, если бы Erlang поддерживал ОО, чего на самом деле нет (если вы услышали то, что мы на самом деле сказали и умеете внимательно читать мелкий шрифт).

Здесь мне вспоминается ключевая речь главы IBM во Франции, которая была адресована аудитории 7-й конференции IEEE Logic programming в Париже. В IBM Prolog было добавлено большое количество ОО-расширений. На вопрос “зачем”, он отвечал: “Наши заказчики хотят ОО prolog, вот мы и сделали ОО prolog “.

Помню, я еще подумал – как просто, без угрызений совести, без самокопаний, без вопросов – “а правильным ли путем идем?”

**Почему ОО – полный отстой**

Мой принципиальный протест против ООП восходит к его базовым идеям, поэтому я опишу их и мои возражения к ним.

**Возражение 1 – Структуры данных и функции не должны быть связаны вместе**

Объекты связывают функции и структуры данных вместе в неделимые модули. Я думаю, это фундаментальная ошибка, поскольку функции и структуры данных принадлежат абсолютно разным мирам. Почему?

- Функции работают. Они имеют ввод и вывод. Ввод и вывод являются структурами данных, которые изменяются функциями. Во многих языках функции строятся как последовательность приказов: “Сделай это, а потом – то”. Чтобы понять функции, вы должны понять порядок, в котором они работают (в ленивых языках функционального программирования и логических языках, это ограничение ослаблено).
- Структуры данных просто есть. Они не делают ничего. Они действительно декларативны. “Понимание” структуры данных гораздо проще “понимания” функции.

Функции представляют собой черные ящики, которые трансформируют ввод в вывод. Если я понимаю ввод и вывод, то я понимаю функцию. Это не означает, что я могу написать эту функцию.

Функции обычно “понимаются” путем наблюдения за тем, как они выполняют работу в вычислительной системе, чьим заданием является преобразование структуры данных типа T1 в структуру данных типа T2.

Поскольку функции и структуры данных являются совершенно разными типами “животных”, было бы фундаментально некорректно помещать их в одну “клетку”.

**Возражение 2 – Все является объектом.**

Рассмотрим “время”. В ОО языке “время” является объектом, а в не-ОО языке, “время” является экземпляром типа данных. Например, в Erlang имеется большое количество различных разновидностей времени, которые могут быть явно и однозначно заданы с использованием деклараций типов:

```

-deftype day() = 1..31.
-deftype month() = 1..12.
-deftype year() = int().
-deftype hour() = 1..24.
-deftype minute() = 1..60.
-deftype second() = 1..60.
-deftype abstime() = {abstime, year(), month(), day(), hour(), min(), sec()}.
-deftype hms() = {hms, hour(), min(), sec()}.
...
```

Обратите внимание, что эти определения не принадлежат ни к какому частичному объекту. Они являются общими, и этими структурами данных может манипулировать любая функция в системе.

Здесь нет ассоциированных методов.

**Возражение 3 – В объектно-ориентированных языках программирования (ООЯП), определения типов данных разбросаны повсюду.**

В ООЯП, определения типов данных принадлежат объектам. Поэтому я не могу найти все определенная данных в одном месте. В Erlang или C я могу определить все типы данных в одном включаемом файле или в словаре данных. В ООЯП я так не могу – определения типов данных разбросаны повсюду.

Позвольте мне привести пример этого. Предположим, я хочу определить общую структуру данных. Общий тип является типом, который встречается во всей системе.

Лисп-программисты давно знают, что лучше иметь небольшое количество общих типов и большое количество небольших функций, которые работают с ними, чем иметь большое количество типов данных и небольшое количество функций для работы с ними.

Общей структурой данных может быть что-то наподобие связанного списка, массива, хэш-таблицы или более сложный объект вроде времени или даты или имени файла.

В ООЯП я должен выбрать определенный базовый объект, который я определю в общей структуре данных, все остальные объекты, которые должны использовать эту структуру, должны наследоваться от этого объекта. Предположим, теперь я хочу создать некоторый объект “время” – кому он должен принадлежать в этом объекте?..

**Возражение 4 – Объекты имеют внутреннее состояние.**

Состояние – корень всех зол. В частности, следует избегать функций с побочными эффектами.

В то время как состояние в языках программирования является нежелательным, реальный мир богат на состояния. Я очень интересуюсь состоянием моего банковского счета. И когда я вкладываю или снимаю с него деньги, я ожидаю, что его состояние будет корректно обновлено.

Исходя из того, что состояние является частью реального мира, какие средства должны для работы с ним должны обеспечивать языки программирования?

- ООЯП говорят “спрячем состояние от программиста”. Состояния скрыты и наблюдаемы только через функции доступа.
- Традиционные языки программирования (С, Паскаль) говорят, что видимость переменных состояния контролируется правилами языка.
- Чистые декларативные языки говорят, что состояний не существует. Глобальное состояние системы передается во все функции и извлекается из них обратно. Механизмы типа монад (для функциональных языков) и DCGs (логические языки) используются для того, чтобы скрыть состояние от программистов. Таким образом, они могут программировать “как будто состояние не имеет значения” но имеют при этом полный доступ к состоянию системы, если это необходимо.

Выбранный ООЯП подход “спрятать состояние от программиста” является наихудшим возможным выбором. Вместо показа состояния и поиска путей для минимизации неудобств от него, они прячут его поглубже.

**Почему ООП стало популярным?**

- Причина 1 – Считается, что оно легкое для обучения.
- Причина 2 – Считается, что оно делает повторное использование кода легче.
- Причина 3 – Оно очень разрекламировано.
- Причина 4 – Оно создало новую софтверную индустрию.

Для меня не очевидны пункты 1 и 2. Причины кажутся движущей силой этой технологии. Если языковая технология настолько плоха, что создает новую индустрию для решения проблем, которые сама же и создает, она должна быть ценной идеей для парней, которые хотят заработать деньги.

И это является реальной движущей силой ООП.