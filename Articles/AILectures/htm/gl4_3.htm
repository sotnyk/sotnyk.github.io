<html>
<head>
	<title>Пролог</title>
	<link rel=stylesheet href="..\css\lectures.css" type="text/css">
	<meta charset="utf-8"/>
</head>

<body bgcolor="#F2F2F2">

<center><h3><a NAME="_Toc429431292">Пролог</a></h3></center>

<p>Данную главу нельзя рассматривать как учебник по языку Пролог, а только как краткий &quot;ликбез&quot;, 
служащий для иллюстрации принципов продукционного программирования, описанных выше.</p>

<center>
<p>&nbsp;
<br><br>
<b><i>
<a NAME="_Toc429431293">Синтаксис</a>
</i></b>
</p>
</center>

<p class="titel"><a NAME="_Toc429431294"><b>
ТЕРМЫ</b></a></p>


<p>Объекты данных в Прологе называются термами. Терм может быть константой, переменной или составным термом 
(структурой). Константами являются целые и действительные числа, например:</p>

<p>0, -l, 123.4, 0.23E-5,</p>

<p>(некоторые реализации Пролога не поддерживают действительные числа).</p>

<p>К константам относятся также атомы, такие, как:</p>

<p>голди, а, атом, +, :, 'Фред Блогс', [].</p>

<p>Атом есть любая последовательность символов, заключенная в одинарные кавычки. Кавычки опускаются, если и без 
них атом можно отличить от символов, используемых для обозначения переменных. Приведем еще несколько примеров 
атомов:</p>

<p>abcd, фред, ':', Джо.</p>

<p>Полный синтаксис атомов описан ниже.</p>

<p>Как и в других языках программирования, константы обозначают конкретные элементарные объекты, а все другие
типы данных в Прологе составлены из сочетаний констант и переменных.</p>

<p>Имена переменных начинаются с заглавных букв или с символа подчеркивания &quot;_&quot;. Примеры переменных:</p>

<p>X, Переменная, _3, _переменная.</p>

<p>Если переменная используется только один раз, необязательно называть ее. Она может быть записана как анонимная 
переменная, состоящая из одного символа подчеркивания &quot;_&quot;. Переменные, подобно атомам, являются 
элементарными объектами языка Пролог.</p>

<p>Завершает список синтаксических единиц сложный терм, или структура. Все, что не может быть отнесено к переменной 
или константе, называется сложным термом. Следовательно, сложный терм состоит из констант и переменных.</p>

<p>Теперь перейдем к более детальному описанию термов.</p>

<p class="titel"><a NAME="_Toc429431295"><b>КОНСТАНТЫ</b></a></p>


<p>Константы известны всем программистам. В Прологе константа может быть атомом или числом.</p>

<p class="titel"><a NAME="_Toc429431296"><b>ATOM</b></a></p>

<p>Атом представляет собой произвольную последовательность символов, заключенную в одинарные кавычки. Одинарный 
символ кавычки, встречающийся внутри атома, записывается дважды. Когда атом выводится на печать, внешние символы
кавычек обычно не печатаются. Существует несколько исключений, когда атомы необязательно записывать в кавычках. 
Вот эти исключения:</p>

<p>1) атом, состоящий только из чисел, букв и символа подчеркивания и начинающийся со строчной буквы;</p>

<p>2) атом, состоящий целиком из специальных символов. К специальным символам относятся:</p>

<p>+ - * / ^ = : ; ? @ $ &amp;</p>

<p>Заметим, что атом, начинающийся с /*, будет воспринят как начало комментария, если он не заключен в одинарные 
кавычки.</p>

<p>Как правило, в программах на Прологе используются атомы без кавычек.</p>

<p>Атом, который необязательно заключать в кавычки, может быть записан и в кавычках. Запись с внешними кавычками и 
без них определяет один и тот же атом.</p>

<p>Внимание: допустимы случаи, когда атом не содержит ни одного символа (так называемый 'нулевой атом') или содержит 
непечатаемые символы. (В Прологе имеются предикаты для построения атомов, содержащих непечатаемые или 
управляющие символы.) При выводе таких атомов на печать могут возникнуть ошибки.</p>

<p class="titel"><a NAME="_Toc429431297"><b>ЧИСЛА</b></a></p>

<p>Большинство реализации Пролога поддерживают целые и действительные числа. Для того чтобы выяснить, каковы 
диапазоны и точность, чисел следует обратиться к руководству по конкретной реализации.</p>

<p class="titel"><a NAME="_Toc429431298"><b>ПЕРЕМЕННЫЕ</b></a></p>
  
<p>Понятие переменной в Прологе отличается от принятого во многих языках программирования. Переменная не 
рассматривается как выделенный участок памяти. Она служит для обозначения объекта, на который нельзя сослаться
по имени. Переменную можно считать локальным именем для некоторого объекта.</p>

<p>Синтаксис переменной довольно прост. Она должна начинаться с прописной буквы или символа подчеркивания и 
содержать только символы букв, цифр и подчеркивания.</p>

<p>Переменная, состоящая только из символа подчеркивания, называется анонимной и используется в том случае, 
если имя переменной несущественно.</p>

<p class="titel"><a NAME="_Toc429431299"><b>ОБЛАСТЬ ДЕЙСТВИЯ ПЕРЕМЕННЫХ</b></a></p>

<p>Областью действия переменной является утверждение. В пределах утверждения одно и то же имя принадлежит одной и 
той же переменной. Два утверждения могут использовать одно имя переменной совершенно различным образом.
Правило определения области действия переменной справедливо также в случае рекурсии и в том случае, когда несколько  
утверждений имеют одну и ту же головную цель. Этот вопрос будет рассмотрен в далее.</p>

<p>Единственным исключением из правила определения области действия переменных является анонимная переменная, 
например, “_” в цели любит(Х,_). Каждая анонимная переменная есть отдельная сущность. Она применяется тогда, когда
конкретное значение переменной несущественно для данного утверждения. Таким образом, каждая анонимная переменная
четко отличается от всех других анонимных переменных в утверждении.</p>

<p>Переменные, отличные от анонимных, называются именованными, а неконкретизированные (переменные, которым не
было присвоено значение) называются свободными.</p>

<p class="titel"><a NAME="_Toc429431300"><b>СЛОЖНЫЕ ТЕРМЫ, ИЛИ СТРУКТУРЫ</b></a></p>

<p>Структура состоит из атома, называемого главным функтором, и последовательности термов, называемых
компонентами структуры. Компоненты разделяются запятыми и заключаются в круглые скобки.</p>

<p>Приведем примеры структурированных термов:</p>

<p>собака(рекс), родитель(Х,У).</p>

<p>Число компонент в структуре называется арностью структуры. Так, в данном примере структура собака имеет арность 1
(записывается как собака/1), а структура родитель -арность 2 (родитель/2). Заметим, что атом можно рассматривать как 
структуру арности 0.</p>

<p>Для некоторых типов структур допустимо использование альтернативных форм синтаксиса. Это синтаксис операторов 
для структур арности 1 и 2, синтаксис списков для структур в форме списков и синтаксис строк для структур, являющихся 
списками кодов символов.</p>

<p class="titel"><a NAME="_Toc429431301"><b>СИНТАКСИС ОПЕРАТОРОВ</b></a></p>

<p>Структуры арности 1 и 2 могут быть записаны в операторной форме, если атом, используемый как главный функтор в 
структуре, объявить оператором (см. гл. 6).</p>

<p class="titel"><a NAME="_Toc429431302"><b>СИНТАКСИС СПИСКОВ</b></a></p>


<p>В сущности, список есть не что иное, как некоторая структура арности 2. Данная структура становится интересной и 
чрезвычайно полезной в случае, когда вторая компонента тоже является списком. Вследствие важности таких структур в
Прологе имеются специальные средства для записи списков. Возможности обработки списков рассматриваются в разд. 5.1.</p>

<p class="titel"><a NAME="_Toc429431303"><b>СИНТАКСИС СТРОК</b></a></p>

<p>Строка определяется как список кодов символов. Коды символов имеют особое значение в языках программирования. 
Они выступают как средство связи компьютера с внешним миром. В большинстве реализации Пролога существует
специальный синтаксис для записи строк. Он подобен синтаксису атомов. Строкой является любая последовательность 
символов, которые могут быть напечатаны (кроме двойных кавычек), заключенная в двойные кавычки. Двойные кавычки в
пределах строки записываются дважды “”.</p>

<p>В некоторых реализациях Пролога строки рассматриваются как определенный тип объектов подобно атомам или 
спискам. Для их обработки вводятся специальные встроенные предикаты. В других реализациях строки обрабатываются в 
точности так же, как списки, при этом используются встроенные предикаты для обработки списков. Поскольку все строки 
могут быть определены как атомы или как списки целых чисел, и понятие строки является чисто синтаксическим, мы не 
будем более к нему возвращаться.</p>

<p class="titel"><a NAME="_Toc429431304"><b>УТВЕРЖДЕНИЯ</b></a></p>


<p>Программа на Прологе есть совокупность утверждений. Утверждения состоят из целей и хранятся в базе данных 
Пролога. Таким образом, база данных Пролога может рассматриваться как программа на Прологе. В конце утверждения 
ставится точка “.”. Иногда утверждение называется предложением.</p>

<p>Основная операция Пролога - доказательство целей, входящих в утверждение.</p>

<p>Существуют два типа утверждений:</p>

<p>факт: это одиночная цель, которая, безусловно, истинна;</p>

<p>правило: состоит из одной головной цели и одной или более хвостовых целей, которые истинны при некоторых условиях.</p>

<p>Правило обычно имеет несколько хвостовых целей в форме конъюнкции целей.</p>

<p>Конъюнкцию можно рассматривать как логическую функцию И. Таким образом, правило согласовано, если согласованы 
все его хвостовые цели.</p>

<p>Примеры фактов:</p>

<p>собака(реке). родитель(голди.рекс).</p>

<p>Примеры правил:</p>

<p>собака (X) :- родитель (X.Y),собака (Y). человек(Х) :-мужчина(Х).</p>

<p>Разница между правилами и фактами чисто семантическая. Хотя для правил мы используем синтаксис операторов 
(более подробное рассмотрение операторного и процедурного синтаксисов выходит за рамки нашего курса), нет никакого 
синтаксического различия между правилом и фактом.</p>

<p>Так, правило</p>

<p>собака (X) :- родитель(Х,У),собака(У). может быть задано как</p>

<p>:-собака (X) ',' родитель(Х.У) .собака (Y).</p>

<p>Запись верна, поскольку :- является оператором “при условии, что”, а ',' - это оператор конъюнкции. Однако удобнее 
записывать это как</p>

<p>собака (X) :-родитель (X.Y),собака (Y).</p>

<p>и читать следующим образом: “ Х - собака при условии, что родителем Х является Y и Y - собака”.</p>

<p>Структуру иногда изображают в виде дерева, число ветвей которого равно арности структуры. </p>

<p><img SRC="..\img\image84.gif" WIDTH="320" HEIGHT="272"></p>

<p class="titel"><a NAME="_Toc429431305"><b>ЗАПРОСЫ</b></a></p>

<p>После записи утверждений в базу данных вычисления могут быть инициированы вводом запроса.</p>

<p>Запрос выглядит так же, как и целевое утверждение, образуется и обрабатывается по тем же правилам, но он не входит 
в базу данных (программу). В Прологе вычислительная часть программы и данные имеют одинаковый синтаксис. 
Программа обладает как декларативной, так и процедурной семантикой. Мы отложим обсуждение этого вопроса до 
последующих глав. Запрос обозначается в Прологе утверждением ?-, имеющим арность 1. Обычно запрос записывается в
операторной форме: за знаком ?- следует ряд хвостовых целевых утверждений (чаще всего в виде конъюнкции).</p>

<p>Приведем примеры запросов:</p>

<p>?-собака(X). ?- родитель(Х.У),собака (Y).</p>

<p>или, иначе,</p>

<p>'?-'(собака(Х)) С?-')
','(родитель(Х„У”,собака (Y)).</p>

<p>Последняя запись неудобна тем, что
разделитель аргументов в структуре совпадает с
символом конъюнкции. Программисту нужно помнить
о различных значениях символа ','.</p>

<p>Запрос иногда называют управляющей
командой (директивой), так как он требует от
Пролог-системы выполнения некоторых действий. Во
многих реализациях Пролога для управляющей
команды используется альтернативный символ, а
символ ?- обозначает приглашение верхнего уровня
интерпретатора Пролога. Альтернативным символом
является :-. Таким образом,</p>

<p>:-write(co6aкa).</p>

<p>- это управляющая команда, в результате
выполнения которой печатается атом собака.
Управляющие команды будут рассмотрены ниже при
описании ввода программ.</p>


<p class="titel"><a NAME="_Toc429431306"><b>ВВОД программ</b></a></p>


<p>Введение списка утверждений в
Пролог-систему осуществляется с помощью
встроенного предиката consult. Аргументом предиката
consult является атом, который обычно
интерпретируется системой как имя файла,
содержащего текст программы на Прологе. Файл
открывается, и его содержимое записывается в
базу данных. Если в файле встречаются
управляющие команды, они сразу же выполняются.
Возможен случай, когда файл не содержит ничего,
кроме управляющих команд для загрузки других
файлов. Для ввода утверждений с терминала в
большинстве реализации Пролога имеется
специальный атом, обычно user. С его помощью
утверждения записываются в базу данных, а
управляющие команды выполняются немедленно.</p>

<p>Помимо предиката consult, в Прологе
существует предикат reconsult. Он работает
аналогичным образом. Но перед добавлением
утверждений к базе данных из нее автоматически
удаляются те утверждения, головные цели которых
сопоставимы с целями, содержащимися в файле
перезагрузки. Такой механизм позволяет вводить
изменения в базу данных. В Прологе имеются и
другие методы добавления и удаления утверждений
из базы данных. Некоторые реализации языка
поддерживают модульную структуру, позволяющую
разрабатывать модульные программы. </p>

<p>В заключение раздела дадим формальное
определение синтаксиса Пролога, используя форму
записи Бэкуса-Наура, иногда называемую
бэкусовской нормальной формой (БНФ).</p>

<p>запрос ::- голова утверждения</p>

<p>правило ::– голова утверждения :- хвост
утверждения</p>

<p>факт ::- голова утверждения </p>

<p>голова утверждения ::-атом | структура </p>

<p>хвост утверждения ::- атом структура, </p>

<p>термы ::-терм [,термы]</p>

<p>терм ::- число | переменная | атом |
структура </p>

<p>структура ::-атом (термы)</p>


<p>Данное определение синтаксиса не
включает операторную, списковую и строковую
формы записи. Полное определение дано в
приложении А. Однако, любая программа на Прологе
может быть написана с использованием
вышеприведенного синтаксиса. Специальные формы
только упрощают понимание программы. Как мы
видим, синтаксис Пролога не требует пространного
объяснения. Но для написания хороших программ
необходимо глубокое понимание языка.</p>

<p class="titel"><a NAME="_Toc429431307"><b>Унификация</b></a></p>


<p>Одним из наиболее важных аспектов
программирования на Прологе являются понятия унификации
(отождествления) и конкретизации переменных.</p>


<p>Пролог пытается отождествить термы
при доказательстве, или согласовании, целевого
утверждения. Например, в программе из гл. 1 для
согласования запроса ?- собака(Х) целевое
утверждение собака (X) было отождествлено с
фактом собака (реке), в результате чего
переменная Х стала конкретизированной: Х= рекc.</p>


<p>Переменные, входящие в утверждения,
отождествляются особым образом - сопоставляются.
Факт доказывается для всех значений переменной
(переменных). Правило доказывается для всех
значений переменных в головном целевом
утверждении при условии, что хвостовые целевые
утверждения доказаны. Предполагается, что
переменные в фактах и головных целевых
утверждениях связаны квантором всеобщности.
Переменные принимают конкретные значения на
время доказательства целевого утверждения.</p>

<p>В том случае, когда переменные
содержатся только в хвостовых целевых
утверждениях, правило считается доказанным, если
хвостовое целевое утверждение истинно для
одного или более значений переменных.
Переменные, содержащиеся только в хвостовых
целевых утверждениях, связаны квантором
существования. Таким образом, они принимают
конкретные значения на то время, когда целевое
утверждение, в котором переменные были
согласованы, остается доказанным.</p>

<p>Терм Х сопоставляется с термом Y по следующим
правилам. Если Х и Y - константы, то они сопоставимы,
только если они одинаковы. Если Х является
константой или структурой, а Y -
неконкретизированной переменной, то Х и Y
сопоставимы и Y принимает значение Х (и наоборот).
Если Х и Y -
структуры, то они сопоставимы тогда и только
тогда, когда у них одни и те же главный функтор и
арность и каждая из их соответствующих компонент
сопоставима. Если Х и Y - неконкретизированные
(свободные) переменные, то они сопоставимы, в этом
случае говорят, что они сцеплены. В (Таблица 2) приведены примеры
отождествимых и неотождествимых термов.</p>


<p class="picture"><a NAME="_Ref428533625">Таблица 2</a>. Иллюстрация унификации.</p>
<div align="center"><center>

<table BORDER="1" CELLSPACING="1" CELLPADDING="3" WIDTH="555">
  <tr>
    <td WIDTH="34%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="28"><p>Терм1</td>
    <td WIDTH="32%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="28"><p>Терм2</td>
    <td WIDTH="34%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="28"><p>Отождествимы ?</td>
  </tr>
  <tr>
    <td WIDTH="34%" VALIGN="TOP" HEIGHT="111"><p
   >джек(Х) </p>
    <p>джек (личность) </p>
    <p>джек(Х,Х) </p>
    <p>джек(Х.Х) </p>
    <p>джек( . ) </p>
    <p>f(Y,Z) </p>
    <p>Х</td>
    <td WIDTH="32%" VALIGN="TOP" HEIGHT="111"><p
   >джек (человек) </p>
    <p>джек (человек) </p>
    <p>джек(23,23) </p>
    <p>джек (12,23) </p>
    <p>джек(12,23) </p>
    <p>Х </p>
    <p>Z</td>
    <td WIDTH="34%" VALIGN="TOP" HEIGHT="111"><p
   >да: Х=человек </p>
    <p>нет </p>
    <p>да: Х=23 </p>
    <p>нет </p>
    <p>да </p>
    <p>да: X=f(Y,Z) </p>
    <p>да: X=Z</td>
  </tr>
</table>
</center></div>

<p>Заметим, что Пролог находит наиболее
общий унификатор термов. В последнем примере
(рис.2.1) существует бесконечное число
унификаторов:</p>


<p>X-1, Z-2; X-2, Z-2; ....</p>


<p>но Пролог находит наиболее общий: Х=Z.</p>

<p>Следует сказать, что в большинстве
реализации Пролога для повышения эффективности
его работы допускается существование
циклических унификаторов. Например, попытка
отождествить термы f(X) и Х приведет к
циклическому унификатору X=f(X), который
определяет бесконечный терм f(f(f(f(f(...))))). В
программе это иногда вызывает бесконечный цикл.</p>

<p>Возможность отождествления двух
термов проверяется с помощью оператора =.</p>

<p>Ответом на запрос</p>


<p>?- 3+2=5. </p>


<p>будет </p>

<p>нет</p>

<p>так как термы не отождествимы
(оператор не вычисляет значения своих
аргументов), но попытка доказать</p>

<p>?-строка(поз(Х)) -строка(поз(23)). </p>

<p>закончится успехом при </p>

<p>Х=23.</p>

<p>Унификация часто используется для
доступа к подкомпонентам термов. Так, в
вышеприведенном примере Х конкретизируется
первой компонентой терма поз(23), который в свою
очередь является компонентой терма строка.</p>

<p>Бывают случаи, когда надо проверить,
идентичны ли два терма. Выполнение оператора = =
заканчивается успехом, если его аргументы -
идентичные термы. Следовательно, запрос</p>

<p>?-строка(поз(Х)) --строка (поз (23)). </p>

<p>дает ответ </p>

<p>нет</p>

<p>поскольку подтерм Х в левой части (X -
свободная переменная) не идентичен подтерму 23 в
правой части, Однако запрос</p>

<p>?- строка (поз (23)) --строка (поз (23)). </p>

<p>дает ответ</p>

<p>да</p>


<p>Отрицания операторов = и - =
записываются как \= и \= = соответственно.</p>

<p class="titel"><a NAME="_Toc429431308"><b>Арифметические выражения</b></a></p>


<p>В этой главе показано, каким образом
Пролог выполняет арифметические операции. Будут
описаны арифметические операторы и их
использование в выражениях, а также рассмотрены
встроенные предикаты, служащие для вычисления и
сравнения арифметических выражений.</p>


<p class="titel"><a NAME="_Toc429431309"><b>Введение</b></a></p>


<p>Язык Пролог не предназначен для
программирования задач с большим количеством
арифметических операций. Для этого используются
процедурные языки программирования. Однако в
любую Пролог-систему включаются все обычные
арифметические операторы:</p>

<p>+ сложение</p>

<p>— вычитание</p>

<p>* умножение </p>

<p>/ деление</p>

<p>mod остаток от деления целых чисел </p>


<p>div
целочисленное деление</p>

<p>В некоторых реализациях языка Пролог
присутствует более широкий набор встроенных
арифметических операторов.</p>

<p>Пролог позволяет также сравнивать
арифметические выражения, используя следующие
встроенные предикаты:</p>

<p>Диапазоны чисел, входящих в
арифметические выражения, зависят от реализации
Пролога. Например, система ICLPROLOG оперирует с целыми числами со
знаком в диапазоне</p>


<p>–8388606 ... 8388607</p>


<p class="titel"><a NAME="_Toc429431310"><b>Арифметические выражения</b></a></p>


<p>Арифметическое выражение является
числом или структурой. В структуру может входить
одна или более компонент, таких, как числа,
арифметические операторы, арифметические
списковые выражения, переменная,
конкретизированная арифметическим выражением,
унарные функторы, функторы преобразования и
арифметические функторы.</p>

<p>Числа. Числа и их диапазоны
определяются в конкретной реализации Пролога.</p>

<p>Арифметические операторы. + - * / mod div</p>

<p>Арифметические списковые выражения.
Если Х - арифметическое выражение, то список [X ]
также является арифметическим выражением,
например [1,2,3]. Первый элемент списка
используется как операнд в выражении. Скажем,</p>


<p>X is ([l,2,3]+5)</p>


<p>имеет значение 6.</p>

<p>Арифметические списковые выражения
полезны и при обработке символов, поскольку
последние могут рассматриваться как небольшие
целые числа. Например, символ &quot;а&quot;
эквивалентен [97 ] и, будучи использован в
выражении, вычисляется как 97. Поэтому значение
выражения “р”+&quot;А&quot;-&quot;а&quot; равно 80, что
соответствует коду ASCII для “Р”.</p>

<p>Переменная, конкретизированная
арифметическим выражением. Примеры:</p>

<p>Х-5+2 и У-3*(2+А)</p>

<p>Унарные функторы. Примеры:</p>

<p>+(Х) и -(У)</p>


<p>Функторы преобразования. В
некоторых реализациях Пролога имеется
арифметика с плавающей точкой, а следовательно, и
функторы преобразования. Например:</p>

<p>float (X) преобразует целое число Х в число
с плавающей точкой.</p>

<p>Математические функторы. Пример:
квадрат(Х) объявлен как оператор и эквивалентен
арифметическому выражению (Х*Х).</p>


<p class="titel"><a NAME="_Toc429431311"><b>Арифметические операторы</b></a></p>


<p>Атомы +, -, *, /, mod и div - обычные атомы
Пролога и могут использоваться почти в любом
контексте. Указанные атомы - не встроенные
предикаты, а функторы, имеющие силу только в
пределах арифметических выражений. Они
определены как инфиксные операторы. Эти атомы
являются главными функторами в структуре, а сама
структура может принимать только описанные выше формы.</p>

<p>Позиция, приоритет и ассоциативность
арифметических операторов четко заданы и
перечислены в таблице операторов в гл. 6.</p>

<p>Арифметический оператор выполняется
следующим образом. Во-первых, вычисляются
арифметические выражения по обе стороны
оператора. Во-вторых, над результатом вычислений
выполняется нужная операция.</p>

<p>Арифметические операторы
определяются Пролог-системой. Если мы напишем
предикат</p>

<p>среднее (X,Y,Z) :- Z is (X+Y)/2.</p>

<p>то хотя можно определить среднее как
оператор</p>

<p>?- ор(250^х, среднее).</p>

<p>но Пролог выдаст сообщение об ошибке,
если встретит выражение Z is X среднее Y.</p>

<p>Это произойдет потому, что Х среднее Y
не образует арифметического выражения, а среднее
не является арифметическим оператором,
определенным в системе.</p>


<p class="titel"><a NAME="_Toc429431312"><b>Вычисление арифметических выражений</b></a></p>


<p>В Прологе не допускаются присваивания
вида Сумма=2+4.</p>

<p>Выражение такого типа вычисляется
только с помощью системного предиката is,
например:</p>

<p>Сумма is 2 + 4.</p>

<p>Предикат is определен как инфиксный
оператор. Его левый аргумент - или число, или
неконкретизированная переменная, а правый
аргумент - арифметическое выражение.</p>

<p>Попытка доказательства целевого
утверждения Х is Y заканчивается успехом в одном
из следующих случаев:</p>

<p>а) Х - неконкретизированная переменная,
а результат вычисления выражения Y есть число;</p>

<p>б) Х - число, которое равно результату
вычисления выражения Y. Цель Х is Y не имеет
побочных эффектов и не может быть согласована
вновь. Если Х не является неконкретизированной
переменной или числом, или если Y - не
арифметическое выражение, возникает ошибка.</p>

<p>Примеры:</p>

<p>D is 10- 5 заканчивается успехом и D
становится равным 5 </p>

<p>4 is 2 * 4 - 4 заканчивается успехом </p>

<p>2 * 4 - 4 is 4 заканчивается неудачей </p>

<p>a is 3 + 3 заканчивается неудачей </p>

<p>X is 4 + а заканчивается неудачей </p>

<p>2 is 4 - X заканчивается неудачей</p>

<p>Обратите внимание, что предикат is
требует, чтобы его первый аргумент был числом или
неконкретизированной переменной. Поэтому М - 2 is 3
записано неверно. Предикат is не является
встроенным решателем уравнений.</p>


<p class="titel"><a NAME="_Toc429431313"><b>Сравнение результатов арифметических выражений</b></a></p>

<p>Системные предикаты =:=, =\=, &gt;,
&lt;, &gt;= и &lt;= определены как инфиксные
операторы и применяются для сравнения
результатов двух арифметических выражений.</p>

<p>Для предиката @ доказательство
целевого утверждения X@Y заканчивается успехом,
если результаты вычисления арифметических
выражений Х и Y находятся в таком отношении друг к
другу, которое задается предикатом @.</p>

<p>Такое целевое утверждение не имеет
побочных эффектов и не может быть согласовано
вновь. Если Х или Y - не арифметические выражения,
возникает ошибка.</p>

<p>С помощью предикатов описываются
следующие отношения:</p>

<p>Х =:= Y Х равно Y</p>

<p>Х =\= Y Х не равно Y</p>

<p>Х &lt; Y Х меньше Y</p>

<p>Х &gt; Y Х больше Y</p>

<p>Х &lt;= Y Х меньше или равно Y</p>

<p>Х &gt;= Y Х больше или равно Y</p>

<p>Использование предикатов
иллюстрируют такие примеры:</p>

<p>а &gt; 5 заканчивается неудачей </p>


<p>5+2+7 &gt; 5+2 заканчивается
успехом </p>


<p>3+2 =:= 5 заканчивается
успехом </p>


<p>3+2 &lt; 5 заканчивается
неудачей </p>


<p>2 + 1 =\= 1 заканчивается
успехом </p>


<p>N &gt; 3 заканчивается
успехом, если N больше 3, и неудачей в противном
случае</p>

<p class="titel"><a NAME="_Toc429431314"><b>Структуры данных</b></a></p>


<p>Термы Пролога позволяют выразить
самую разнообразную информацию. В настоящей
главе мы рассмотрим два вида широко используемых
структур данных: списки и бинарные деревья, и
покажем, как они представляются термами Пролога.</p>


<p class="titel"><a NAME="_Toc429431315"><b>Списки</b></a></p>


<p>СПИСКОВАЯ ФОРМА ЗАПИСИ</p>

<p>Задачи, связанные с обработкой
списков, на практике встречаются очень часто.
Скажем, нам понадобилось составить список
студентов, находящихся в аудитории. С помощью
Пролога мы можем определить список как
последовательность термов, заключенных в скобки.
Приведем примеры правильно построенных списков
Пролога:</p>

<p>[джек, джон, фред, джилл, джон] </p>

<p>[имя (джон, смит), возраст (джек, 24), X] </p>

<p>[Х.У.дата (12,январь, 1986) ,Х] </p>


<p>[]</p>


<p>Запись [H|T] определяет список,
полученный добавлением Н в начало списка Т.
Говорят, что Н - голова, а Т - хвост списка [HIT]. На
вопрос</p>

<p>?-L=[a | [b, c, d]]. будет получен ответ</p>


<p>L=[a, b, c, d] </p>


<p>а на запрос</p>

<p>?-L= [a, b, c, d], L2=[2 | L]. - ответ</p>


<p>L=[a, b, c, d], L2- [2, a, b, c, d]</p>


<p>Запись [Н | Т] используется для того,
чтобы определить голову и хвост списка. Так,
запрос</p>

<p>?- [X | Y]=[a, b, c]. дает</p>

<p>Х=а, Y=[b, c]</p>

<p>Заметим, что употребление имен
переменных Н и Т необязательно. Кроме записи вида
[H|T], для выборки термов используются переменные.
Запрос</p>


<p>?-[a, X, Y]=[a, b, c].</p>


<p>определит значения </p>


<p>X=b</p>

<p>Y=c</p>


<p>а запрос</p>

<p>?- [личность(Х) | Т]=[личность(джон), а, b].</p>

<p>значения</p>

<p>Х=джон </p>

<p>Т=[а, Ь]</p>

<p>НЕКОТОРЫЕ СТАНДАРТНЫЕ ЦЕЛЕВЫЕ
УТВЕРЖДЕНИЯ ДЛЯ ОБРАБОТКИ СПИСКОВ</p>

<p>Покажем на примерах, как можно
использовать запись вида [Н | T] вместе с рекурсией
для определения некоторых полезных целевых
утверждений для работы со списками,</p>

<p>Принадлежность списку. Сформулируем
задачу проверки принадлежности данного терма
списку.</p>

<p>Граничное условие:</p>

<p>Терм R содержится в списке [H|T], если R=H.</p>

<p>Рекурсивное условие:</p>

<p>Терм R содержится в списке [H|T], если R
содержится в списке Т.</p>

<p>Первый вариант записи определения на
Прологе имеет вид:</p>

<p>содержится (R, L) :-</p>

<p>L=[H I T],</p>

<p>H=R. </p>


<p>содержится(Р, L) :-</p>


<p>L=[H|T],</p>


<p>содержится (R, T).</p>

<p>Цель L=[H I T] в теле обоих утверждений
служит для того, чтобы разделить список L на
голову и хвост.</p>

<p>Можно улучшить программу, если учесть
тот факт, что Пролог сначала сопоставляет с целью
голову утверждения, а затем пытается согласовать
его тело. Новая процедура, которую мы назовем
принадлежит, определяется таким образом:</p>

<p>принадлежит (R, [R | Т]). </p>

<p>принадлежит (R, [H | Т]) :- принадлежит (R, T).</p>

<p>На запрос</p>

<p>?- принадлежит(а, [а, Ь, с]).</p>


<p>будет получен ответ</p>

<p>да </p>

<p>на запрос</p>

<p>?- принадлежит(b, [a, b, с]).</p>

<p>- ответ</p>

<p>да </p>

<p>но на запрос</p>

<p>?- принадлежит(d, (a, b, c)).</p>

<p>Пролог дает ответ</p>

<p>нет</p>

<p>В большинстве реализации Пролога
предикат принадлежит является встроенным.</p>

<p>Соединение двух списков. Задача
присоединения списка Q к списку Р, в результате
чего получается список R, формулируется
следующим образом:</p>

<p>Граничное условие:</p>

<p>Присоединение списка Q к [] дает Q.</p>

<p>Рекурсивное условие:</p>

<p>Присоединение списка Q к концу списка Р
выполняется так: Q присоединяется к хвосту Р, а
затем спереди добавляется голова Р.</p>

<p>Определение можно непосредственно
написать на Прологе:</p>

<p>соединить([],0,0). </p>

<p>соединить(Р,Q,Р) :-</p>

<p>Р=[НР | ТР],</p>

<p>соединить(TP, Q, TR),</p>


<p>R=[HP | TR].</p>


<p>Однако, как и в предыдущем примере,
воспользуемся тем, что Пролог сопоставляет с
целью голову утверждения, прежде чем пытаться
согласовать тело:</p>

<p>присоединить([] ,Q,Q). </p>

<p>присоединить(HP | TP], Q, [HP | TR]) :-</p>

<p>присоединить (TP, Q, TR).</p>

<p>На запрос</p>

<p>?- присоединить [а, b, с], [d, e], L). </p>

<p>будет получен ответ</p>


<p>L = [a, b, c, d]. </p>


<p>но на запрос</p>

<p>?- присоединить([a, b], [c, d], [e, f]). </p>

<p>ответом будет </p>

<p>нет</p>

<p>Часто процедура присоединить
используется для получения списков, находящихся
слева и справа от данного элемента:</p>

<p>присоединить (L [джим, р], [джек,.билл,
джим, тим, джим, боб] ) .</p>


<p>L = [джек, билл]</p>

<p>R = [тим, джим, боб]</p>

<p>другие решения (да/нет)? да</p>

<p>L=[джек, билл, джим, тим]</p>

<p>R=[боб]</p>

<p>другие решения (да/нет)? да</p>

<p>других решений нет</p>

<p>Индексирование списка. Задача
получения N-ro терма в списке определяется
следующим образом:</p>

<p>Граничное условие:</p>

<p>Первый терм в списке [Н | Т] есть Н.</p>

<p>Рекурсивное условие:</p>

<p>N-й терм в списке [Н | Т] является (N-I)-м
термом в списке Т.</p>

<p>Данному определению соответствует
программа:</p>

<p>/* Граничное условие:</p>

<p>получить ([H | Т], 1, Н). /* Рекурсивное
условие:</p>

<p>получить([Н | Т], N, У) :-</p>

<p>М is N - 1, </p>

<p>получить (Т, М ,Y).</p>

<p>Построение списков из фактов. Иногда
бывает полезно представить в виде списка
информацию, содержащуюся в известных фактах. В
большинстве реализации Пролога есть необходимые
для этого предикаты:</p>


<p>bagof(X,Y,L) определяет
список термов L, конкретизирующих переменную Х
как аргумент предиката Y, которые делают истинным
предикат Y</p>

<p>setof(X,Y,L) все сказанное о предикате bagof
относится и к setof, за исключением того, что список
L отсортирован и из него удалены все повторения.</p>

<p>Если имеются факты:</p>

<p>собака(рекс). </p>

<p>собака (голди). </p>

<p>собака (фидо). </p>

<p>собака(реке).</p>

<p>то на запрос</p>

<p>?- bagof(D, co6aкa(D), L), </p>

<p>будет получен ответ</p>

<p>L=[реке, голди, фидо, рекс] </p>

<p>в то время как</p>

<p>?-setof(D, co6aкa(D), L). дает значение</p>

<p>L=[фидо, голди, рекc]</p>

<p>Пример: сложение многочленов</p>

<p>Теперь мы достаточно подготовлены к
тому, чтобы использовать списки для решения
задач. Вопрос, которым мы займемся, -
представление и сложение многочленов.</p>

<p>Представление многочленов. Посмотрим,
как можно представить многочлен вида</p>

<p>Р(х)=3+3х-4х^3+2х^9 </p>

<p>Q(х)=4х+х^2-3х^3+7х^4+8х^5</p>

<p>Заметим, что каждое подвыражение
(такое, как Зх ^3, Зх, 3) имеет самое большее две
переменные компоненты: число, стоящее перед х,
называемое коэффициентом, и число, стоящее после
^ - степень. Следовательно, подвыражение
представляется термом</p>

<p>х(Коэффициент, Степень)</p>

<p>Так, 5х^2 записывается как х(5,2), х^З
представляется как х(1,3), а поскольку х^0 равно 1,
подвыражению 5 соответствует терм х(5,0).</p>

<p>Теперь запишем многочлен в виде
списка. Приведенный выше многочлен Р(х), например,
будет выглядеть следующим образом:</p>


<p>[x(3, 0), '+', x(3, l), '-', x(4, 3), '+', x(2, 9)]</p>


<p>Воспользуемся тем, что многочлен</p>

<p>3 + 3х - 4х^3 + 2х^9</p>

<p>допускает замену на эквивалентный</p>

<p>3 + 3х + (-4)х^3 + 2х^9 Тогда он выражается
списком:</p>

<p>[х(3, 0), '+', х(3, 1), '+', х(-4, 3), '+', х(2, 9)]</p>

<p>В такой записи между термами всегда
стоят знаки '+'. Следовательно, их можно опустить,
и многочлен принимает окончательный вид:</p>

<p>[х(3, 0), х(3, 1), х(-4, 3), х(2, 9)]</p>

<p>Подразумевается, что между всеми
термами списка стоят знаки '+'. Представлением
многочлена Q(x) будет</p>

<p>[х(4, 1), х(1, 2), х(-3, 3), х(7, 4), х(8, 5)]</p>

<p>Сложение многочленов. Теперь напишем
целевые утверждения для сложения двух
многочленов. Сложение многочленов</p>

<p>3-2х^2+4х^3+6х^6 </p>

<p>-1+3х^2-4х^3</p>


<p>в результате дает</p>

<p>2+х^2+6х^6</p>


<p>Аргументами целевого утверждения
являются многочлены, представленные в виде
списков. Ответ будет получен также в виде списка.</p>

<p>Сложение многочлена Р с многочленом Q
осуществляется следующим образом:</p>

<p>Граничное условие:</p>

<p>Р, складываемый с [], дает Р. </p>

<p>[], складываемый с Q, дает Q.</p>

<p>Рекурсивное условие:</p>

<p>При сложении Р с Q, в результате чего
получается многочлен R, возможны 4 случая:</p>

<p>а) степень первого терма в Р меньше, чем
степень первого терма в Q. В этом случае первый
терм многочлена Р образует первый терм в R, а
хвост R получается при прибавлении хвоста Р к Q.
Например, если Р и Q имеют вид</p>

<p>Р(х)=3х^2+5х^3 </p>


<p>Q(x)=4x^3+3x^4</p>


<p>то первый терм R(x) равен 3х^2 (первому
терму в Р(х)). Хвост R(x) равен 9х^3+3х^4, т.е. результату
сложения Q(x) и хвоста Р(х);</p>

<p>б) степень первого терма в Р больше
степени первого терма в Q. В данном случае первый
терм в Q образует первый терм в R, а хвост R
получается при прибавлении Р к хвосту Q. Например,
если</p>

<p>Р(х)=2х^3+5х^'4 </p>


<p>Q(x)=3x^3-x^4</p>


<p>то первый терм R(x) равен 3х^2 (первому
терму в Q(x)), а хвост R(x) равен 2х^3+4х^4 (результату
сложения Р(х) и хвоста Q(x));</p>

<p>в) степени первых термов в Р и Q равны, а
сумма их коэффициентов отлична от нуля. В таком
случае первый терм в R имеет коэффициент, равный
сумме коэффициентов первых термов в Р и Q. Степень
первого терма в R равна степени первого терма в Р
(или Q). Хвост R получается при сложении хвоста Р и
хвоста Q. Например, если Р и Q имеют вид</p>

<p>Р(х)=2х+3х^3 </p>


<p>Q(x)=3x+4x^4</p>


<p>то первый терм многочлена R (х) равен 5х
(результату сложения первого терма в Р(х) с первым
термом в Q(x)). Хвост R(x) равен 3х^3+4х^4 (результату
сложения хвоста Р(х) и хвоста Q(x));</p>

<p>г) степени первых термов в Р и Q
одинаковы, но сумма коэффициентов равна нулю. В
данном случае многочлен R равен результату
сложения хвоста Р с хвостом Q. Например, если</p>

<p>р(х)=2+2х </p>


<p>Q(x)=2-3x^2</p>


<p>то</p>


<p>R(x)=2x-3x^2</p>


<p>(это результат сложения хвостов
многочленов Р (х) и Q (х)).</p>

<p>Рассмотренный процесс сложения многочленов можно
непосредственно записать на языке Пролог:</p>

<p>/* Граничные условия </p>

<p>слож_мн([], Q Q).</p>

<p>слож_мн(P, [], P).</p>

<p>/* Рекурсивное
условие</p>


<p>/* (a)</p>


<p>слож_мн([x(Pc, Pp)|Pt], [x(Qc, Qp)|Qt], </p>

<dir>
  <dir>
    <p>[x(Pc,Pp)IRt]) :-</p>
    <dir>
      <dir>
        <p>PpQp,</p>
        <p>слож_мн(Рt, [х(Qс,Qр) | Qt], Rt). </p>
      </dir>
    </dir>
  </dir>
</dir>


<p>/*(б)</p>

<p>слож_мн([x(Pc, Pp) | Pt], [x(Qc, Qp) | Qt],
</p>

<dir>
  <dir>
    <p>[x(Qc, Qp) | Rt]) :-</p>
    <dir>
      <dir>
        <p>PpQp,</p>
        <p>слож_мн([x(Pc, Pp) | Pt], Qt, Rt). </p>
      </dir>
    </dir>
  </dir>
</dir>


<p>/*(в)</p>

<p>слож_мн([x(Pc, Pp) | Pt], [х(Qc,Pp) | Qt], </p>

<dir>
  <dir>
    <p>[x(Rc, Pp) | Rt]) :-</p>
    <dir>
      <dir>
        <p>Rc is Pc+Qc,</p>
        <p>Rc =\= 0,</p>
        <p>слож_мн(Pt, Qt,Rt). </p>
      </dir>
    </dir>
  </dir>
</dir>

<p>/*(r) </p>


<p>слож_мн([х(Рс, Рр) | Pt], </p>

<dir>
  <dir>
    <p>[x(Qc.Pp) | Qt], Rt) :-</p>
    <dir>
      <dir>
        <p>Re is Pc+Qc,</p>
        <p>Rc =:= 0,</p>
        <p>слож_мн(Pt, Qt, Rt).</p>
      </dir>
    </dir>
  </dir>
</dir>


<p>Заметим, что в двух последних
утверждениях проверка на равенство
осуществляется следующим образом: степени
первых термов складываемых утверждений
обозначает одна и та же переменная Pp.</p>


<p>Списки как термы. В начале главы мы
упомянули о том, что список представляется с
помощью терма. Такой терм имеет функтор '.', Два
аргумента и определяется рекурсивно. Первый
аргумент является головой списка, а второй -
термом, обозначающим хвост списка. Пустой список
обозначается []. Тогда список [а, b] эквивалентен терму.(а,.(b, [])).</p>


<p>Таким образом, из списков, как и из
термов, можно создавать вложенные структуры.
Поэтому выражение</p>


<p>[[a, b], [c, d], [a], a]</p>


<p>есть правильно записанный список, и на
запрос</p>


<p>?- [Н | Т]=[[а, b], с]. </p>

<p>Пролог дает ответ</p>

<p>Н=[а, b] </p>


<p>Т=[с]</p>

<p class="titel"><a NAME="_Toc429431316"><b>Бинарные деревья</b></a></p>


<p class="titel"><a NAME="_Toc429431317"><b>ПРЕДСТАВЛЕНИЕ БИНАРНЫХ ДЕРЕВЬЕВ</b></a></p>


<p>Бинарное дерево определяется
рекурсивно как имеющее левое поддерево, корень и
правое поддерево. Левое и правое поддеревья сами
являются бинарными деревьями. На Рис. 2 показан пример бинарного
дерева.</p>


<p><img SRC="..\img\image85.gif" WIDTH="320" HEIGHT="242"></p>


<p class="picture"><a NAME="_Ref428545692">Рис. 2</a>. Бинарное дерево.</p>


<p>Такие деревья можно представить
термами вида</p>

<p>бд(Лд, К, Пд),</p>

<p>где Лд - левое поддерево, К - корень, а Пд
- правое поддерево. Дл” обозначения пустого
бинарного дерева будем использовать атом nil.
Бинарное дерево на рис.5.2.1 имеет левое поддерево</p>

<p>бд(бд(nil, d, nil), b, бд(nil, е, nil))</p>


<p>правое поддерево</p>

<p>бд(nil,с, nil)</p>


<p>и записывается целиком как</p>

<p>бд(бд(бд(nil,d, nil), b, бд(nil,е, nil)), а, бд(nil, с, nil)).</p>


<p class="titel"><a NAME="_Toc429431318"><b>ПРЕДСТАВЛЕНИЕ МНОЖЕСТВ С ПОМОЩЬЮ БИНАРНЫХ ДЕРЕВЬЕВ</b></a></p>


<p>Описание множеств в виде списков
позволяет использовать для множеств целевое
утверждение принадлежит, определенное ранее для
списков.</p>

<p>Однако для множеств, состоящих из
большого числа элементов, списковые целевые
утверждения становятся неэффективными.
Рассмотрим, например, как целевое утверждение
принадлежит (см. предыдущий разд.) позволяет
моделировать принадлежность множеству. Пусть L - список,
описывающий множество из первых 1024 натуральных
чисел. Тогда при ответе на запрос</p>

<p>?- принадлежит(3000, b).</p>

<p>Прологу придется проверить все 1024
числа, прежде чем заключить, что такого числа нет:</p>

<p>нет</p>

<p>Представление множества бинарным
деревом позволяет добиться лучшего результата.
При этом бинарное дерево должно быть упорядочено
таким образом, чтобы любой элемент в левом
поддереве был меньше, чем значение корня, а любой
элемент в правом поддереве — больше. Поскольку мы определили
поддерево как бинарное дерево, такое
упорядочение применяется по всем поддеревьям. На
Рис. 3
приведен пример упорядоченного бинарного
дерева.</p>

<p>Дерево на Рис. 2 является неупорядоченным.</p>


<p><img SRC="..\img\image86.gif" WIDTH="320" HEIGHT="206"></p>


<p class="picture"><a NAME="_Ref428548839">Рис. 3</a>. Упорядоченное бинарное
дерево.</p>


<p>Обратите внимание, что упорядочение
приводит не к единственному варианту
представления множества с помощью дерева.
Например, на Рис. 4 изображено то же множество, что и на Рис. 3.</p>


<p>Будем называть линейным представление
такого вида, как на Рис. 4, и сбалансированным - такое, как
на Рис. 3.</p>

<p><img SRC="..\img\image87.gif" WIDTH="400" HEIGHT="341"></p>


<p class="picture"><a NAME="_Ref428548991">Рис. 4</a>. Линейное представление.</p>


<p>Моделирование принадлежности
множеству. Имея множество, описанное бинарным
деревом, мы можем моделировать принадлежность
множеству с помощью целевого утверждения
принадлежит_дереву. При этом используется
оператор @&lt;, выражающий отношение “меньше,
чем”, и оператор @&gt;, выражающий отношение
“больше, чем”.</p>

<p>/* Граничное условие: Х принадлежит </p>

<p>/* дереву, если Х является корнем.</p>

<p>принадлежит_дереву(Х, бд(Лд, Х, Пд)),</p>

<p>/* Рекурсивные условия </p>

<p>/* Х принадлежит дереву, если Х больше </p>

<p>/* значении корня и находится в правом </p>

<p>/* поддереве:</p>

<p>принадлсжит_дереву(Х, бд(Лд, У, Пд)) :- X@Y,</p>

<p>припадлежит_дереву(Х, Пд).</p>

<p>/* Х принадлежит дереву, если Х меньше </p>

<p>/* значения корня и находится в левом </p>

<p>/* поддереве:</p>

<p>принадлежит_дереву(Х, бд(Лд ,У ,Пд)) :-X@Y, </p>

<p>принадлежит_дереву(Х, Лд).</p>

<p>Если множество из первых 1024 чисел
описать с помощью сбалансированного бинарного
дерева Т, то при ответе на запрос</p>

<p>?- принадлежит_дереву(3000, Т).</p>


<p>Пролог сравнит число 3000 не более чем с
11 элементами множества. прежде чем ответит:</p>

<p>нет</p>

<p>Конечно, если Т имеет линейное
представление, то потребуется сравнение 3000 с 1024
элементами множества.</p>

<p>Построение бинарного дерева. Задача
создания упорядоченного бинарного дерева при
добавлении элемента Х к другому упорядоченному
бинарному дереву формулируется следующим
образом:</p>

<p>Граничное условие:</p>

<p>Добавление Х к nil дает бд(nil, Х, nil).</p>

<p>Рекурсивные условия:</p>

<p>При добавлении Х к бд(Лд, К, Пд) нужно рассмотреть два
случая, чтобы быть уверенным, что результирующее
дерево будет упорядоченным.</p>

<p>1. Х меньше,чем К. В этом случае нужно
добавить Х к Лд, чтобы получить левое поддерево.
Правое поддерево равно Пд, а значение корня
результирующего дерева равно К.</p>

<p>2. Х больше, чем К. В таком случае нужно
добавить Х к Пд, чтобы получить правое поддерево.
Левое поддерево равно Лд, а значение корня - К.</p>

<p>Такой формулировке задачи
соответствует программа:</p>

<p>/* Граничное условие:</p>

<p>включ_бд(nil, Х, бд(nil, Х, nil)). </p>


<p>/* Рекурсивные условия:</p>


<p>/*(1) </p>


<p>включ_бд(бд(Лд, К, Пд), Х, бд(Лднов, К, Пд)) :-</p>

<dir>
  <dir>
    <p>Х@К,</p>
    <p>включ_бд(Лд,Х,Лднов). </p>
  </dir>
</dir>


<p>/*(2) </p>


<p>включ_бд(бд(Лд, К, Пд), Х, бд(Лд, К, Пднов))
:-</p>

<dir>
  <dir>
    <p>Х@К,</p>
    <p>включ_бд(Пд, Х, Пднов).</p>
  </dir>
</dir>

<p>На запрос</p>

<p>?- включ_бд(nil, d, Т1), включ_бд(Т1, а, Т2). </p>

<p>будут получены значения</p>

<p>Т1=бд(nil, d, nil)</p>


<p>Т2=бд(бд(nil, а, nil), d, nil) </p>


<p>Процедуру включ_бд() можно
использовать для построения упорядоченного
дерева из списка:</p>

<p>/* Граничное условие:</p>

<p>список_в_дерево([], nil). </p>


<p>/* Рекурсивное условие:</p>

<p>список_в_дерево([Н | Т], Бд) :-</p>

<dir>
  <dir>
    <p>список_в_дерево(Т, Бд2),</p>
    <p>включ_бд(Н, Бд2, Бд).</p>
  </dir>
</dir>

<p>Заметим, что включ_бд не
обеспечивает построения сбалансированного
дерева. Однако существуют алгоритмы,
гарантирующие такое построение.</p>

<p class="titel"><a NAME="_Toc429431319"><b>Механизм возврата и процедурная семантика</b></a></p>


<p>При согласовании целевого утверждения
в Прологе используется метод, известный под
названием механизма возврата. В этой главе мы
показываем, в каких случаях применяется механизм
возврата, как он работает и как им пользоваться.
Описывается декларативная и процедурная
семантика процедур Пролога. Завершается глава
обсуждением вопросов эффективности.</p>


<p class="titel"><a NAME="_Toc429431320"><b>Механизм возврата</b></a></p>


<p>При попытке согласования целевого
утверждения Пролог выбирает первое из тех
утверждений, голова которых сопоставима с
целевым утверждением. Если удастся согласовать
тело утверждения, то целевое утверждение
согласовано. Если нет, то Пролог переходит к
следующему утверждению, голова которого
сопоставима с целевым утверждением, и так далее
до тех пор, пока целевое утверждение не будет
согласовано или не будет доказано, что оно не
согласуется с базой данных.</p>

<p>В качестве примера рассмотрим
утверждения:</p>

<p>меньше(X.Y) :- </p>

<dir>
  <dir>
    <p>XY, write(X), </p>
    <p>write ('меньше,
    чем'),write(Y).</p>
  </dir>
</dir>

<p>меньше(Х.У) :- </p>

<dir>
  <dir>
    <p>XY, write(Y), </p>
    <p>write ('меньше,
    4CM'),write(X).</p>
  </dir>
</dir>

<p>Целевое утверждение </p>

<p>?- меньше (5, 2).</p>


<p>сопоставляется с головой первого
утверждения при Х=5 и У=2. Однако не удается
согласовать первый член конъюнкции в теле
утверждения X&lt;Y. Значит, Пролог нс может
использовать первое утверждение для
согласования целевого утверждения меньше(5, 2).
Тогда Пролог переходит к следующему утверждению,
голова которого сопоставима с целевым
утверждением. В нашем случае это второе
утверждение. При значениях переменных Х=5 и Y=2 тело утверждения
согласуется. Целевое утверждение меньше(5,2)
доказано, и Пролог выдает сообщение “2 меньше,
чем 5”. Запрос</p>

<p>?-меньше (2, 2).</p>


<p>сопоставляется с головой первого
утверждения, но тело утверждения согласовать не
удается. Затем происходит сопоставление с
головой второго утверждения, но согласовать тело
опять-таки оказывается невозможно. Поэтому
попытка доказательства целевого утверждения
меньше(2, 2) заканчивается неудачей.</p>

<p>Такой процесс согласования целевого
утверждения путем прямого продвижения по
программе мы называем прямой трассировкой (forward tracking). Даже
если целевое утверждение согласовано, с помощью
прямой трассировки мы можем попытаться получить
другие варианты его доказательства, т.е. вновь
согласовать целевое утверждение.</p>

<p>Пролог производит доказательство
конъюнкции целевых утверждений слева направо.
При этом может встретиться целевое утверждение,
согласовать которое не удается. Если такое
случается, то происходит смещение влево до тех
пор, пока не будет найдено целевое утверждение,
которое может быть вновь согласовано, или не
будут ис черпаны все предшествующие целевые
утверждения. Если слева нет целевых утверждений,
то конъюнкцию целевых утверждений согласовать
нельзя. Однако, если предшествующее целевое
утверждениг может быть согласовано вновь, Пролог
возобновляет процесс доказательства целевых
утверждений слева направо, начиная со следующего
справа целевого утверждения. Описанный процесс
смещения влево для повторного согласования
целевого утверждения и возвращения вправо носит
название механизма возврата.</p>


<p class="titel"><a NAME="_Toc429431321"><b>Пример: задача поиска пути в лабиринте</b></a></p>


<p>В качестве примера использования
механизма возврата напишем процедуру для поиска
пути в лабиринте. Лабиринт представлен фактами
вида:</p>

<p>стена(I, J) для позиции в I-м ряду и J-й колонке, где есть
стена </p>

<p>отсутств_стена(I, J) для позиции в I-м ряду и J-й колонке, где нет
стены</p>

<p>выход (I, J) для позиции в 1-м ряду и J-й
колонке, являющейся выходом</p>

<p>Рассмотрим небольшой лабиринт:</p>
<div align="center"><center>

<table BORDER="1" CELLSPACING="3" CELLPADDING="9" WIDTH="80%">
  <tr>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" HEIGHT="25" align="center"></td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#000000" HEIGHT="25" 	align="center"><strong><font color="#FFFFFF">Выход</strong></td>
    <td WIDTH="20%" VALIGN="TOP" HEIGHT="25" align="center"></td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
  </tr>
  <tr>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" HEIGHT="25" align="center"></td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#c0c0c0" HEIGHT="25" align="center">Стена</td>
  </tr>
</table>
</center></div>

<p>Последний ряд лабиринта описывается
фактами:</p>

<p>стена(4,1). </p>

<p>стена(4,3). </p>

<p>стена(4,4). </p>

<p>отсутств_стена(4,2).</p>

<p>Если задана исходная позиция, путь к
выходу можно найти следующим образом.</p>

<p>Граничное условие:</p>

<p>Если исходная позиция является
выходом, то путь найден.</p>

<p>Рекурсивные условия:</p>

<p>Ищем путь из исходной позиции в
северном направлении. Если пути нет, идем на юг.
Если пути нет, идем на запад. Если нельзя, идем на
восток. Если соседняя позиция на севере (юге,
западе, востоке) является стеной, то нет смысла
искать путь из начальной позиции к выходу. Чтобы
не ходить кругами, будем вести список позиций, в
которых мы побывали.</p>

<p>Изложенному способу решения задачи
соответствует процедура путь: она ищет путь
(второй аргумент) к выходу из некоторой позиции
(первый аргумент). Третьим аргументом является
список позиций, где мы побывали.</p>

<p>/* Терм a(I, J) представляет позицию в </p>


<p>/* I-м ряду и J-й
колонке. </p>

<p>/* Нашли путь ? </p>

<p>путь(а(I, J),[а(I, J)], Были) :- выход(I, J).</p>


<p>/* Пытаемся идти на север </p>

<p>путь(а(I, J),[а(I, J) | Р], Были) :-</p>

<dir>
  <dir>
    <p>К is I-1,</p>
    <p>можем_идти(a (K, J), Были),</p>
    <p>путь(а(I, J) ,Р, [a(K, J) | Были]).</p>
  </dir>
</dir>

<p>/* Пытаемся идти на юг </p>

<p>путь(а(I, J),[а(I, J) | Р], Были) :-</p>

<dir>
  <dir>
    <p>К is I+1,</p>
    <p>можем_идти(a (K, J), Были),</p>
    <p>путь(а(I, J) ,Р, [a(K, J) | Были]).</p>
  </dir>
</dir>

<p>/* Пытаемся идти на запад </p>

<p>путь(а (I, J), [a (I, J) | P], Были) :-</p>

<dir>
  <dir>
    <p>L is J-1,</p>
    <p>можем_идти(а(I, L), Были),</p>
    <p>путь(а(I, L), Р, [а(I, L)| Были]).</p>
  </dir>
</dir>

<p>/* Пытаемся идти на восток </p>

<p>путь(а (I, J), [a (I, J) | P], Были) :-</p>

<dir>
  <dir>
    <p>L is J+1,</p>
    <p>можем_идти(а(I, L), Были),</p>
    <p>путь(а(I, L), Р, [а(I, L)| Были]).</p>
  </dir>
</dir>

<p>/* в позицию a(I, J) можно попасть при </p>

<p>/* условии, что там нет стены и мы </p>

<p>/* не побывали в ней прежде </p>

<p>можем_идти(а(I, J)), Были) :-</p>

<dir>
  <dir>
    <p>отсутств_стена(I, J),</p>
    <p>not
    (принадлежит (a (I, J), Были)).</p>
  </dir>
</dir>

<p>Для того чтобы понять, каким образом
процедура ищет путь к выходу, рассмотрим процесс
согласования запроса с описанием лабиринта,
описанного выше:</p>

<p>?-путь(а(4,2), Р, [а(4.2)]).</p>

<p>Выходом из лабиринта является позиция
выход (3,1).</p>

<p>Выбор первого утверждения не приводит
к согласованию целевого утверждения, поскольку а
(4,2) - не выход. Во втором утверждении делается
попытка найти путь в северном направлении, т.е.
согласовать целевое утверждение</p>

<p>путь(а(3, 2), Р2, [а(3, 2), а(4, 2)]).</p>

<p>Целевое утверждение не удается
согласовать с первым утверждением</p>

<p>путь(а(3, 2), Р2, [а(3, 2), а(4, 2)])</p>

<p>так как а (3,2) не является выходом. Во
втором утверждении предпринимается попытка
найти путь, двигаясь на север, т.е. согласовать
целевое утверждение</p>

<p>путь(а(2,2), РЗ, [а(2, 2), а(3, 2), а(4, 2)]).</p>

<p>Ни одно из утверждений не может
согласовать</p>

<p>путь(а(2, 2), РЗ, [а(2, 2), а(3, 2), а(4, 2)]).</p>

<p>Первое утверждение - потому, что а (2, 2)
не является выходом, второе - потому, что северная
позиция является стеной, третье утверждение -
потому, что в южной позиции мы уже побывали, а
четвертое и пятое утверждения - потому, что
западная и восточная границы - это стены.</p>

<p>Неудача в согласовании</p>

<p>путь(а(2, 2), РЗ, [а(2, 2), а(3, 2), а(4, 2)])</p>

<p>заставляет Пролог-систему вернуться в
ту точку, где было выбрано второе утверждение при
попытке согласовать</p>

<p>путь(а(3, 2), Р2, [а(3, 2), а(4, 2)]).</p>

<p>Решение пересматривается и выбирается
третье утверждение.</p>

<p>В третьем утверждении осуществляется
попытка найти путь, двигаясь на юг, но она
оказывается неудачной, поскольку мы уже побывали
в позиции а (4, 2). Тогда, чтобы согласовать</p>

<p>путь(а(3, 2), Р2, [а(3, 2), а(4, 2)]),</p>

<p>выбирается четвертое утверждение. Мы
успешно находим путь, двигаясь в западном
направлении к позиции а(3,1), которая и является
выходом. Рекурсия сворачивается, и в результате
получается путь</p>

<p>Р=[а(4, 2),а(3, 2), а(3,1)] </p>

<p>другие решения(да/нет)? да</p>

<p>Других решений нет</p>

<p>Альтернативный путь</p>


<p>[a(4,2), a(3,2), a(2,2), a(3,2), a(3,1)]</p>


<p>мы получить не можем, потому что не
разрешается дважды бывать в одной и той же
позиции.</p>

<p>Описанная процедура не обязательно
находит кратчайший путь к выходу. Кратчайший
путь можно найти, генерируя альтернативные пути
с помощью вызова состояния неудачи и запоминая
кратчайший из них.</p>

</body>
</html>
