<html>
<head>
	<title>Глава 4</title>
	<link rel=stylesheet href="..\css\lectures.css" type="text/css">
	<meta charset="utf-8"/>
</head>

<body bgcolor="#F2F2F2">

<center><h3><a NAME="_Toc429431283">Глава 4. </a><a NAME="L8_11"></a>Логический подход к построению систем ИИ</h3>

<p>
<small><b>
Представление в компьютере неформальных процедур. Языки логического программирования Рефал, Пролог, 
К-системы. Элементы нечеткой логики.
</b></small>

&nbsp;
<br><br><br><br>
<b><i>
<a NAME="_Toc429431284">Неформальные процедуры</a>
</i></b>
</p>
</center>


<p>Говоря о неформальных процедурах мы обычно хорошо понимаем, что имеется в виду, и без затруднений можем 
привести примеры таких процедур, связанных с пониманием текстов естественного языка, переводом с одного 
естественного языка на другой, информационным поиском по смыслу и т. д.</p>

<p>Трудности возникают при попытке точного определения подобных процедур. Так, если рассматривать неформальные 
процедуры всего лишь как абстрактные функции, которые для каждого значения аргумента &quot;выдают&quot; некоторое
значение, то категория неформальности вообще исчезает из рассмотрения.</p>

<p>Неформальная процедура — это особый способ представления функций. Чтобы в какой-то степени приблизиться к этому
&quot;человеческому&quot; способу представления функций, рассмотрим прежде всего традиционные алгоритмические 
модели и попытаемся понять, в чем состоит основная трудность их применения для имитации неформальных процедур.</p>

<p class="titel"><a NAME="_Toc429431285">Алгоритмические модели</a></p>

<p>Алгоритмические модели основаны на понятии алгоритма. Исторически первые точные определения алгоритма, 
возникшие в 30-х годах, были связаны с понятием вычислимости. С тех пор было предложено множество, как выяснилось,
эквивалентных определений алгоритма.</p>

<p>В практике программирования алгоритмы принято описывать с помощью алгоритмических языков программирования. 
Широко используются также разного рода блок-схемы алгоритмов, позволяющие представить алгоритмы в наглядном и
общедоступном виде, не привлекая в тоже время сложных конструкций из конкретных языков программирования.</p>

<p>Чтобы оценить возможности использования алгоритмов для представления неформальных процедур, рассмотрим 
простую задачу.</p>

<p>ЗАДАЧА. Описать процедуру, реализующую преобразование из именительного падежа в родительный для 
существительных следующих типов: ДОМ, МАМА, ВИЛКА, КИНО, НОЧЬ, ТОКАРЬ, КИЛЬ.</p>

<p>Решение 1 указано на Рис. 1 в виде блок схемы соответствующего алгоритма.</p>

<p ALIGN="CENTER"><img SRC="..\img\image83.gif" WIDTH="640" HEIGHT="480"></p>

<p ALIGN="CENTER" class="picture"><a NAME="_Ref400814607">Рис. 1</a>. Решение 1. Алгоритм</p>

<p>С точки зрения программирования на алгоритмических языках достоинства подобного представления очевидны — эта 
блок-схема без затруднений переводится в текст программы, например, на языке Ассемблера или С++. Однако само
составление подобной блок-схемы при появлении существительных новых типов становится, очевидно, все более и более 
утомительным занятием. Для иллюстрации этого предположим, что дана</p>

<p>ДОПОЛНИТЕЛЬНАЯ ЗАДАЧА. Расширить алгоритм, представленный на Рис. 1 на слова ВАСЯ, ВРЕМЯ, АКЦИЯ, ЗАДАЧА.</p>

<p>Разумеется программист без особого труда составит соответствующую блок-схему алгоритма. И все же, если учесть, 
что подобные изменения и расширения алгоритма при программировании неформальных процедур происходят многократно 
(реальная сложность неформальной процедуры как раз и проявляется в практической невозможности предусмотреть
заранее все случаи), следует признать, что, вполне правильное в статике, решение 1 в динамике неудачно!</p>

<p class="titel"><a NAME="_Toc429431286">Продукционные модели</a></p>

<p>В подобных случаях для обеспечения динамичности процессов модификации программ используются те или иные 
варианты таблиц решений. С учетом этого для исходной задачи более приемлемо решение 2:</p>

<center>
<p class="titel"><a NAME="_Ref400898269">Таблица 1</a>. Решение 2</p>
<table BORDER="1" CELLSPACING="1" CELLPADDING="9" WIDTH="550">
  <tr>
    <td WIDTH="25%">Ситуация</td>
    <td WIDTH="25%">Действие</td>
    <td WIDTH="25%">Ситуация</td>
    <td WIDTH="25%">Действие</td>
  </tr>
  <tr>
    <td>КИНО</td>
    <td>КИНО</td>
    <td>-Ь</td>
    <td>-И</td>
  </tr>
  <tr>
    <td>-ча</td>
    <td>-чи</td>
    <td>-ие</td>
    <td>-ия</td>
  </tr>
  <tr>
    <td>-КА</td>
    <td>-КИ</td>
    <td>-мя</td>
    <td>-мени</td>
  </tr>
  <tr>
    <td>-А</td>
    <td>-Ы</td>
    <td>-я</td>
    <td>-и</td>
  </tr>
  <tr>
    <td>-АРЬ</td>
    <td>-АРЯ</td>
    <td>-</td>
    <td>-А</td>
  </tr>
  <tr>
    <td>-Ь &amp; М:хЬ</td>
    <td>-Я</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
</center>

<p>Соответствующая таблица решений содержит две графы — слева приведены описания ситуаций, справа — 
соответствующие действия. Предполагается, что программист разработал интерпретирующую программу для подобных 
таблиц. Эта программа работает следующим образом. Для конкретного входного слова, пусть это будет для примера слово 
РОЗА, осуществляется последовательный просмотр ситуаций, указанных в таблице, и сравнение их со входным словом. 
Если слово соответствует некоторой ситуации, то выполняется действие, указанное для этой ситуации.</p>

<p>Для слова РОЗА будет обнаружено соответствие с ситуацией &quot;-А&quot;. В результате выполнения действия 
&quot;-Ы&quot; будет получено выходное слово РОЗЫ.</p>

<p>Теперь значительно упрощается расширение на новые классы слов — необходимо лишь обеспечить внесение вставок на 
нужное место в таблице решений.</p>

<p>Таблицы решений представляют собой частный случай так называемых продукционных систем. В этих системах правила 
вычислений представляются в виде продукций. Продукции представляют собой операторы специального вида и состоят из 
двух основных частей, для краткости называемых обычно &quot;ситуация — действие&quot;.</p>

<p>&quot;Ситуация&quot; содержит описание ситуации, в которой применима продукция. Это описание задается в виде 
условий, называемых посылками продукции. &quot;Действие&quot; — это набор инструкций, подлежащих выполнению в 
случае применимости продукции.</p>

<p class="titel"><a NAME="_Toc429431287">Режим возвратов</a></p>

<p>Таблица решений, приведенная на Таблица 1, иллюстрирует так называемую безвозвратную процедуру. В этом случае 
на каждом шаге выбирается единственное решение — так, для слова РОЗА таким решением будет РОЗЫ — проблема выбора
решения не возникает. В общем случае неформальные процедуры являются многозначными, а правильность конкретного 
выбора, сделанного на некотором шаге, проверяется на следующих шагах. При этом используется так называемый режим
возвратов.</p>

<p>а). МАТЬ ——————&gt; ЛЮБИТ ——————&gt; ?</p>

<p><sup>что делать? кого?</sup></p>

<p>б). МАТЬ &lt;—————— ЛЮБИТ &lt;—————— ?</p>

<p><sup>кого? что делать?</sup></p>

<p>Пусть предложение начинается со слов МАТЬ ЛЮБИТ ... . Проанализировав эти слова в первоначальном предположении 
именительного падежа для слова МАТЬ, система вправе построить структуру, представленную в случае а). Если следующее 
слово после слова ЛЮБИТ представляет собой существительное в винительном падеже, например, вся фраза имеет вид 
МАТЬ ЛЮБИТ СЫНА, то эта структура является окончательной. Если же фраза имеет вид МАТЬ ЛЮБИТ СЫН, то возникает
противоречие или, как говорят, сигнал неуспеха — очередное слово СЫН противоречит ожиданию прямого дополнения. В 
этом случае система должна вернуться на ближайший из предыдущих шагов, где можно принять другую альтернативу 
анализа. В данном примере это шаг анализа слова МАТЬ — система должна принять теперь альтернативу винительного 
падежа для этого слова. Далее будет построена структура, указанная в случае б).</p>

<p>Тривиальность рассмотренного примера убеждает в необходимости режима возвратов при реализации неформальных 
процедур.</p>

<p class="titel"><a NAME="_Toc429431288">Логический вывод</a></p>

<p>Важность логического вывода становится очевидной уже при рассмотрении простейших информационно-логических 
процедур. Предположим, что некоторая база данных содержит сведения об отношениях &quot;o — ОТЕЦ у&quot; и &quot;х — 
МАТЬ у&quot;. Чтобы обработать запросы типа:</p>

<p>ИВАНОВ А.И. — ДЕД ПЕТРОВА В.А.?</p>

<p>ПЕТРОВ В.А. — ВНУК ИВАНОВА А.И.?</p>

<p>необходимо либо ввести в базу данных также и сведения об отношениях &quot;х — ДЕД у&quot; и &quot;х — ВНУК у&quot;, 
либо объяснить системе, как из отношений ОТЕЦ, МАТЬ извлечь искомую информацию. Реализация первой возможности 
связана с неограниченным ростом избыточности базы данных. Вторая возможность при традиционном алгоритмическом 
подходе требует написания все новых и новых программ для реализации новых типов запросов.</p>

<p>Логический вывод позволяет расширять возможности &quot;общения&quot; наиболее просто и наглядно. Так, для 
приведенных типов запросов системе достаточно будет сообщить три правила:</p>

<p>1. х—ДЕД у если х—ОТЕЦ а и а—РОДИТЕЛЬ у</p>

<p>2. х—РОДИТЕЛЬ у если х—ОТЕЦ у или х—МАТЬ у</p>

<p>3. х—ВНУК у если у—ДЕД х</p>

<p>Эти правила содержат естественные и очевидные определения понятий ДЕД, РОДИТЕЛЬ, ВНУК. Поясним в чем состоит
логический вывод для запроса &quot;А—ДЕД В?&quot; в предположении, что в базе данных имеются факты: А—ОТЕЦ Б и 
Б—МАТЬ В. При этом для упрощения опустим тонкости, связанные с падежными окончаниями. Пользуясь определением 1 
система придет к необходимости проверки существования такого индивидуума а, что факты А—ОТЕЦ а и а—РОДИТЕЛЬ В 
истинны. Если такой а существует, то А—ДЕД В, если не существует такого а, то А не является дедом В.</p>

<p class="titel"><a NAME="_Toc429431289">Зависимость продукций</a></p>

<p>Продукционные системы, содержащие аппарат логического вывода, отличает высокая степень общности правил 
обработки данных. Однако именно эта общность приводит к ухудшению динамических свойств соответствующих 
продукционных программ, к трудностям их модификации и развития. Чтобы понять, в чем тут причина, обратимся снова к 
Таблица 1. Пока эта таблица содержит несколько строк, не представляет особого труда установление правильного порядка 
их следования, но если учесть, что реальное количество продукций в подобных задачах исчисляется сотнями и более, 
трудоемкость их правильного взаимного расположения становится очевидной. Практически, при программировании 
неформальных &quot;человеческих&quot; процедур, подобные таблицы можно вручную создавать и сопровождать для
нескольких десятков продукций, максимум — для 100-200 продукций. Продукции зависимы, и за правильное выявление этой 
зависимости отвечает программист. Новые продукции необходимо вручную вставлять на нужное место.</p>

<p>Мы могли бы использовать в таблице решений только конкретные факты, например правила ДОМ --&gt; ДОМА, 
МАМА --&gt; МАМЫ и т. д., и динамичность соответствующей таблицы решений была бы восстановлена — подобные правила 
можно было бы вводить в произвольном порядке! Однако цена подобной &quot;динамичности&quot; окажется непомерно
высокой — полный отказ от обобщенных правил. </p>

<p>Желательно восстановить динамичность продукционно-логических систем, сохранив при этом в полном объеме 
возможность использования обобщенных правил. Продукционная система должна взять на себя функции распознавания и
интерпретации приоритета продукций — программист должен только описывать ситуации и соответствующие им действия.</p>

<p class="titel"><a NAME="_Toc429431290">Продукционные системы с исключениями</a></p>

<p>Если отношение &quot;правило—исключение&quot; встроено в систему, она сама может понять, что преобразование 
ПАЛКА --&gt; ПАЛКЫ незаконно. При этом система должна руководствоваться простым принципом: если применимо 
исключение, общее правило запрещено. Соответствующие системы будем называть системами с исключениями. </p>

<p>Отношение &quot;общее правило — исключение&quot; безусловно полезно для понимания системой уместности правил. 
Можно сказать, что это отношение устанавливает автоматически (по умолчанию) наиболее типичное для неформальных
процедур взаимодействие правил:</p>

<p>— исключение &quot;вытесняет&quot; общее правило.</p>

<p>— при пересечении разрешены оба правила.</p>

<p>Разумеется, возможны ситуации, когда необходимо поступать наоборот:</p>

<p>— исключение не запрещает общего правила</p>

<p>— при пересечении одно из правил запрещено.</p>

<p>Пусть дано, например, общее правило х --&gt; р<sub>1</sub> и его исключение Ах --&gt; р<sub>2</sub>. Таким образом, 
для произвольного слова необходима реакция р<sub>1</sub>. Для слова же, начинающегося с буквы А, исполняется 
реакция р<sub>2</sub> — по умолчанию для таких слов реакция р<sub>1</sub> незаконна.</p>

<p>Предположим, однако, что по условию конкретной задачи для слов, начинающихся с А, реакция р<sub>1</sub> также 
допустима. В этом случае введение нового правила Ах --&gt; р<sub>1</sub> снимает запрет на реакцию р<sub>1</sub> в 
ситуации Ах.</p>

<p>Аналогичный способ годится для пересечения правил.</p>

<p>Таким образом, аппарат исключений позволяет устанавливать произвольные способы взаимодействия правил, в том 
числе и отличные от взаимодействия по умолчанию.</p>

<p>При развитии продукционной системы с исключениями программист сосредотачивает свое внимание на выявлении 
новых правил и на обобщении уже имеющихся. Аппарат исключений освобождает программиста от решения трудоемких
вопросов согласования правил — распознавание и интерпретация исключений осуществляется автоматически.</p>

</body>
</html>
