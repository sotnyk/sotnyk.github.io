<html>
<head>
	<title>Язык Рефал</title>
	<link rel=stylesheet href="..\css\lectures.css" type="text/css">
	<meta charset="utf-8"/>
</head>

<body bgcolor="#F2F2F2">

<center><h3><a NAME="_Toc429431291">Язык Рефал</a></h3></center>

<p>Название языка происходит от &quot;РЕкурсивных Функции АЛгоригмический язык&quot;. Нас будут также интересовать 
соображения, которые привели к построению этого языка — эти соображения имеют на наш взгляд весьма общий характер 
и полезны для лучшего понимания причин возникновения продукционного подхода в программировании.</p>

<p>Разработчики языка Рефал делят алгоритмические языки на две группы. Первую группу образуют языки, которые 
называются языки операторного, или процедурного типа. Элементарными единицами программы являются здесь 
операторы, т.е. приказы, выполнение которых сводится к четко определенному изменению четко определенной части 
памяти машины. Типичным представителем этой группы является язык машины Поста. Сюда же относятся машинные языки 
конкретных ЭВМ, а также массовые языки программирования типа Фортран, Алгол, ПЛ/1.</p>

<p>Языки второй группы называются языками сентенциального, или декларативного типа (sentence — высказывание, 
предложение). Программа на таком языке представляется в виде набора предложений (соотношений, правил, формул), 
которые машина, понимающая данный язык, умеет каким-то образом применять к обрабатываемой информации.
Простейшим примером сентенциального языка, созданного с теоретическими целями является язык нормальных 
алгоритмов Маркова.</p>

<p>Можно указать прообразы указанных типов алгоритмических языков в естественных языках. Для операторных языков 
это повелительное наклонение (императив, приказание), для сентенциалышх - изъявительное наклонение (описание, 
повествование). Обращаясь к естественному языку, нетрудно заметить, что &quot;изъявительное наклонение является
несравненно более распространенным и образует, в сущности, основу языка, в то время как повелительное наклонение 
предстает в виде некоторой специальной модификации&quot;. Таким образом, можно сделать вывод о том, что 
&quot;относительный вес изъявительного наклонения является мерой развитости языка&quot;.</p>

<p>Язык РЕФАЛ является сентенциальным в своей основе, а вся информация в этом языке представляется в виде правил 
конкретизации. Каждое правило записывается в виде предложения, которое представляет собой продукцию с 
определенными синтаксисом и семантикой. Предложения в Рефал-программе отделяются друг от друга знаком § (параграф).
</p>

<p>Каждое правило конкретизации определяет раскрытие смысла некоторого понятия через более элементарные. 
Операцию конкретизации можно также определить как переход от имени к значению. Введем два знака:</p>

<p>k и <font FACE="Symbol">^</font>, которые будем называть конкретизационными скобками, и которые будут содержать 
объект, подлежащий конкретизации. Так, если х — некоторая переменная, то kx<font FACE="Symbol">^</font> . 
(конкретизация х) будет изображать значение этой величины. Другой пример: объект k28 +7<font FACE="Symbol">^</font> 
при правильном определении операции сложения рано или поздно будет заменен на объект 35.</p>

<p>Выполнение конкретизации — переход от имени к значению — объявляется основной и, по существу, единственной 
операцией в языке Рефал. Эту операцию будет выполнять Рефал-машина (имеется в виду машина на логическом уровне, 
имитируемая соответствующим транслятором на универсальной ЭВМ; возможно, разумеется, и построение реальной
&quot;физической&quot; Рефал-машины).</p>

<p>Поскольку правило конкретизации есть указание для замены одного объекта (слова в некотором алфавите) на другой, 
предложения языка Рефал должны состоять из левой части (заменяемый объект) и правой части (объект, заменяющий 
левую часть). Для разделения правой и левой части мы будем использовать знак стрелки &quot;--&gt;&quot;.</p>

<p>Пример 3.5. Предложение, выражающее тот факт, что значение переменной Х есть 137, записывается в виде</p>

<p>§kX<font FACE="Symbol">^</font> --&gt; 137.</p>

<p>Между знаком § и первым знаком k можно вставлять последовательность знаков, которая будет служить номером 
предложения, или комментарием к нему, например:</p>

<center>
<p>&nbsp;
<br><br>
	<b>
		<a NAME="_Ref428513877">§ l.l kX<font FACE="Symbol">^</font> </a>--&gt;<a NAME="_Ref428513877"> 137.
		<br><br>
	</b>
	</a><a NAME="_Ref428530614">(ф. 1</a>)
</p>
</center>


<p>Опишем теперь структуру Рефал-машины, которая, используя предложения Рефал-программы, будет выполнять 
конкретизации. Будем считать, что объектом обработки является некоторое выражение (слово), которое находится в поле
зрения машины. Работа машины осуществляется по шагам, каждый из которых представляет выполнение одного акта, 
конкретизации.</p>

<p>Пусть программа машины состоит из единственного предложения (ф. 1), а в поле зрения находится выражение 
kX<font FACE="Symbol">^</font> . Тогда за один шаг машина заменит содержимое поле зрения на 137, после чего она 
остановится, т. к. знаков конкретизации больше нет, и следовательно, делать ей больше нечего.</p>

<p>Так как Рефал-программа содержит, вообще говоря, набор (последовательность) предложений, может оказаться, что 
для выполнения данной конкретизации пригодно не одно, а несколько предложений. Например, в поле памяти, кроме 
(ф. 1), может находиться еще предложение</p>

<p>§ 1.2 kX<font FACE="Symbol">^</font> --&gt; 274.</p>

<p>Неоднозначность, которая отсюда может возникнуть, устраняется так же, как это принято в нормальных алгоритмах 
Маркова (читатель, видимо, уже заметил, что Рефал-машина следует идеологии этих алгоритмов): машина просматривает 
предложения в том порядке, в котором они расположены в Рефал-программе, и применяет первое из них, которое 
окажется подходящим.</p>

<p>Поле зрения может содержать сколько угодно конкретизационных скобок, причем они могут быть как угодно вложены 
друг в друга. В этом случае Рефал-машина начинает процесс конкретизации с первого из знаков k, в области действия 
которого (т.е. в последовательности знаков до парной скобки <font FACE="Symbol">^</font> ) нет ни одного знака k. 
Выражение, находящееся в области этого знака k, последовательно. сравнивается с левыми частями предложений 
Рефал-программы. Найдя подходящее предложение, машина выполняет в поле зрения необходимую замену и переходит к
следующему шагу конкретизации.</p>

<p>Пример. Пусть Рефал-программа имеет вид</p>

<p>kX<font FACE="Symbol">^</font> --&gt; 137</p>

<p>kX<font FACE="Symbol">^</font> --&gt; 274</p>

<p>kY<font FACE="Symbol">^</font> --&gt; 2</p>

<p>k137+2<font FACE="Symbol">^</font> --&gt; 139, </p>

<p>а поле зрения содержит выражение</p>

<p>kkX<font FACE="Symbol">^</font> +kY<font FACE="Symbol">^</font> <font FACE="Symbol">^</font> .</p>

<p>На первом шаге замене подлежит подвыражение kX<font FACE="Symbol">^</font> — получим в поле зрения kl37 + 
kY<font FACE="Symbol">^</font> <font FACE="Symbol">^</font> . Теперь в первую очередь конкретизируется 
kY<font FACE="Symbol">^</font> — получим в результате применения третьего предложения 
k137 +2<font FACE="Symbol">^</font> и на последнем шаге получим 139, не содержащее символов k. (Разумеется для 
реального сложения используются соответствующие встроенные функции, а этот пример — лишь простейшая иллюстрация 
принципов работы машины [21]).</p>

<p>Чтобы иметь возможность представлять обобщенные предложения, используются три типа переменных: е — для 
представления выражений; t — для термов; s — для символов. В простейшем случае переменные записываются в виде 
указателя типа (е, t, s) и индекса; например, е<sub>1</sub>, e<sub>2</sub> — переменные, пробегающие в качестве
значений выражения. Выражением в языке Рефал называется последовательность знаков, правильно построенная в 
соответствеии с синтаксисом языка Рефал. Терм языка Рефал — это либо символ, либо выражение в круглых или 
конкретизационных скобках. Выражения строятся из термов.</p>

<p>Пример. Предположим, требуется написать программу, которая выполняет раскрытие скобок в алгебраических 
выражениях, построенных из букв с помощью скобок, знаков сложения &quot;+&quot; и умножения&quot;*&quot;. 
Рассмотрим процесс написания такой программы. Если некоторое выражение е имеет вид е<sub>1</sub> + e<sub>1</sub>, 
где е<sub>1</sub>, e<sub>1</sub> — выражения, то для раскрытия скобок надо: раскрыть скобки в e<sub>1</sub>, раскрыть
скобки в е<sub>2</sub>, полученные результаты сложить. Эту мысль в компактном, но в то же время и наглядном виде
выражает предложение:</p>


<p>§ 2.1 ke<sub>1</sub> +e<sub>2<font FACE="Symbol">^</font> </sub>--&gt; 
ke<sub>1<font FACE="Symbol">^</font> </sub>+ke<sub>2<font FACE="Symbol">^</font> </sub></p>

<p>Если же выражение е имеет вид e<sub>1</sub> * e<sub>2</sub>, то, вообще говоря, необходимо учитывать две
возможности:</p>

<p>— хотя бы один из сомножителей есть сумма (например, е = (А + В) *С),</p>

<p>— ни одно из выражений е<sub>1</sub> или е<sub>2</sub> не представимо в виде суммы (например, е = (А * В) * (С * Л)).</p>

<p>В первом случае надо описать законы дистрибутивности:</p>

<p>§ 2.2ke<sub>1</sub> * (e<sub>2</sub> +e<sub>3</sub>) <font FACE="Symbol">^</font> --&gt; ke<sub>1</sub> 
* e<sub>2<font FACE="Symbol">^</font> </sub>+ke<sub>1</sub>*e<sub>3<font FACE="Symbol">^</font> </sub>,</p>

<p>§ 2.3k(e<sub>1</sub> +e<sub>2</sub>) * e<sub>3<font FACE="Symbol">^</font> </sub>--&gt;<sub> </sub>ke<sub>1</sub>
* e<sub>3<font FACE="Symbol">^</font> </sub>+ ke<sub>2</sub>*e<sub>3<font FACE="Symbol">^</font> </sub>, </p>

<p>§ 2.4ke<sub>1</sub> * (e<sub>2</sub> + e<sub>3</sub>) * e<sub>4</sub> <font FACE="Symbol">^</font> --&gt;
k(e<sub>1</sub> * е<sub>2</sub> + e<sub>1</sub> * e<sub>3</sub>) * e<sub>4<font FACE="Symbol">^</font> </sub>. </p>

<p>Во втором случае по аналогии со сложением имеем </p>

<p>§ 2.5ke<sub>1</sub> * е<sub>2<font FACE="Symbol">^</font> </sub>--&gt; ke<sub>1<font FACE="Symbol">^</font> 
</sub>* ke<sub>2<font FACE="Symbol">^</font> </sub>.</p>

<p>Наконец, осталось выразить возможность &quot;снятия внешних скобок&quot; и условие &quot;терминальности&quot; 
символов, что определяют предложения:</p>

<p>§ 2.6k(e) <font FACE="Symbol">^</font> --&gt; ke<font FACE="Symbol">^</font> , </p>

<p>§ 2.7ks<font FACE="Symbol">^</font> --&gt; s</p>

<p>(буквы не подлежат конкретизации).</p>

<p>Приведенные семь предложений § 2.1 - § 2.7 решают задачу. Рассмотрим как эта программа обрабатывает выражение</p>

<p>k(A +B) * (С +D) <font FACE="Symbol">^</font> . </p>

<p>Последовательно получим в результате работы программы (для удобства слева указываем номер правила, которое 
непосредственно привело к данному выражению):</p>

<p>§2.2 k(A +В)*С<font FACE="Symbol">^</font> . + k(A +B)*D<font FACE="Symbol">^</font> , </p>

<p>§2.3 kA *C<font FACE="Symbol">^</font> +kB*C<font FACE="Symbol">^</font> + k(A+B)*D<font FACE="Symbol">^</font> , </p>

<p>§2.3 kA *C<font FACE="Symbol">^</font> + kB*C<font FACE="Symbol">^</font> + kA *D<font FACE="Symbol">^</font> + 
kB*D<font FACE="Symbol">^</font> . </p>

<p>Далее ограничимся рассмотрением первого слагаемого:</p>

<p>§ 2.5 kA<font FACE="Symbol">^</font> * kC<font FACE="Symbol">^</font> + ..., </p>

<p>§2.7 A * kC<font FACE="Symbol">^</font> + ..., </p>

<p>§ 2.7 А * С + ... .</p>

<p>После аналогичной обработки остальных слагаемых получим искомое выражение</p>

<p>А*С+D*С+А * D + В * D. </p>

<p>Если на вход поступит выражение </p>

<p>kA + (B + С) <font FACE="Symbol">^</font> , </p>

<p>то получим последовательно:</p>

<p>§ 2.1 kA<font FACE="Symbol">^</font> + k(B + С) <font FACE="Symbol">^</font> , </p>

<p>§ 2.7 А + k (Д + С) <font FACE="Symbol">^</font> , </p>

<p>§ 2.6 А + kB + C<font FACE="Symbol">^</font> , </p>

<p>§2.1, 2.7 A + B + С.</p>

<p>Обратите внимание, что если расположить правило § 2.5 перед правилами § 2.2 и § 2.3, то придем к абсурду! Например, 
выражение А *(В+С) будет приведено к виду: А *В + С.</p>

</body>
</html>
